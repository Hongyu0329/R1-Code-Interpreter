def solve_vc_dimension():
    """
    Calculates and demonstrates the VC dimension for the given logic fragment.
    """
    k = 4  # The number of unary predicates in the schema S

    print("="*60)
    print(f"Finding the VC Dimension for FO_[exists, and, T, B][S]")
    print(f"Schema S has {k} unary predicates: P1, P2, P3, P4.")
    print("="*60)

    # --- Part 1: Proof for Lower Bound (VCdim >= 4) ---
    print("\n--- Step 1: Proving the Lower Bound (VCdim >= 4) by Construction ---\n")
    print(f"We will show that a set X of size {k} can be shattered.")
    
    # Let the set of points be X = {0, 1, 2, 3}
    X = set(range(k))
    print(f"Let our set of points be X = {X}.")

    # Define the k predicates P_i = X - {i}
    # P[i] in code corresponds to predicate P_{i+1}
    predicates = [X - {i} for i in range(k)]
    print("We define the 4 predicates over X as follows:")
    for i in range(k):
        print(f"  P{i+1} = X \\ {{{i}}} = {predicates[i]}")

    print("\nThe concept class consists of all intersections of these predicates.")
    print("We will now show that for any subset Y of X, we can find a concept C")
    print("(an intersection of predicates) that isolates Y (i.e., C_intersect_X = Y).\n")

    # Iterate through all 2^k possible subsets of X to show they can all be generated
    num_subsets = 1 << k
    shattered = True
    for i in range(num_subsets):
        # Generate the target subset Y based on the bits of i
        Y = {j for j in range(k) if (i >> j) & 1}

        # The concept C_Y is the intersection of all P_j where j is NOT in Y.
        indices_to_intersect = [j + 1 for j in range(k) if j not in Y]
        
        # Start with the universal set (intersection of zero predicates, i.e., Top)
        concept_result = X.copy()
        for j in range(k):
            if j not in Y:
                concept_result.intersection_update(predicates[j])

        # Verify that the generated concept matches the target subset Y
        if concept_result == Y:
            if not indices_to_intersect:
                formula = "T (Top, the universal set)"
            else:
                formula = " AND ".join([f"P{idx}" for idx in indices_to_intersect])
            
            print(f"Target Subset Y = {Y if Y else '{}'}")
            print(f"  - Generated by C = {formula}")
            print(f"  - Resulting set C_intersect_X = {concept_result if concept_result else '{}'}")
            # print(f"  - Match: {concept_result == Y}\n")
        else:
            print(f"Error: Failed to generate subset {Y}. Shattering failed.")
            shattered = False
            break
    
    if shattered:
        print("\nSuccess! All 2^4 = 16 subsets of X were generated.")
        print(f"This proves that a set of size {k} can be shattered, so VCdim >= {k}.")

    # --- Part 2: Proof for Upper Bound (VCdim <= 4) ---
    print("\n\n--- Step 2: Proving the Upper Bound (VCdim <= 4) by Cardinality ---\n")
    
    num_concepts = 2**k
    print(f"The concept class is formed by intersections of the {k} base predicates.")
    print(f"The number of ways to choose a subset of these {k} predicates is 2^{k} = {num_concepts}.")
    print(f"Therefore, there are at most {num_concepts} distinct concepts in the class.")

    d = k + 1
    required_concepts = 2**d
    print(f"\nTo shatter a set of size d = {d}, we would need to generate 2^{d} = {required_concepts} distinct subsets.")
    print(f"However, we only have at most {num_concepts} concepts available.")
    print(f"Since {required_concepts} > {num_concepts}, we cannot shatter a set of size {d}.")
    print(f"This proves that the VC dimension must be less than {d}, so VCdim <= {k}.")

    # --- Part 3: Conclusion ---
    print("\n\n" + "="*60)
    print("Conclusion")
    print("="*60)
    final_vc_dim = k
    print(f"We have shown VCdim >= {final_vc_dim} (by construction) and VCdim <= {final_vc_dim} (by cardinality).")
    print(f"Therefore, the VC dimension of FO_[exists, and, T, B][S] is exactly {final_vc_dim}.")

solve_vc_dimension()