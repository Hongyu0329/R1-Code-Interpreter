import inspect

def solve():
    """
    This function demonstrates the difference between an unsafe goal (maximizing
    past predictive success) and a safe goal (using an internal value function)
    for a model M that predicts binary sequences.
    """

    # Step 1: Define the hypotheses (predictors) as p.c. functions.
    # In a real scenario, these would be generated by a model M.
    # Here, we pre-define them for clarity.
    def predictor_alternating(sequence):
        """Predicts the next bit will alternate the last one."""
        if not sequence:
            return 0  # Default starting prediction
        return 1 - sequence[-1]

    def predictor_all_ones(sequence):
        """Always predicts 1. A very simple hypothesis."""
        return 1

    def predictor_periodic_110(sequence):
        """Predicts a repeating '110' pattern. A more complex hypothesis."""
        pattern = [1, 1, 0]
        return pattern[len(sequence) % 3]

    # The model M's set of available hypotheses. The names are like GÃ¶del numbers.
    hypotheses = {
        "alternating_pattern": predictor_alternating,
        "all_ones": predictor_all_ones,
        "periodic_110": predictor_periodic_110,
    }

    # Step 2: Define the scenario.
    # The initial part of the sequence suggests an alternating pattern.
    initial_sequence = [1, 0, 1, 0]
    # However, a distributional shift occurs. The true completion breaks the pattern.
    true_next_bit = 1
    
    print(f"Initial sequence: {initial_sequence}")
    print(f"True next bit (revealed after prediction): {true_next_bit}\n")

    # --- Method 1: The Unsafe Goal of Pursuing Predictive Success ---
    print("--- Method 1: Unsafe Goal (Maximize past predictive success) ---")
    best_predictor_name_unsafe = None
    max_score = -1

    for name, func in hypotheses.items():
        # Score a predictor based on its accuracy on the initial sequence.
        correct_predictions = 0
        # We test the predictor on subsequences to see how well it explains the data.
        num_tests = len(initial_sequence) -1
        if num_tests > 0:
            for t in range(1, len(initial_sequence)):
                prefix = initial_sequence[:t]
                prediction = func(prefix)
                if prediction == initial_sequence[t]:
                    correct_predictions += 1
            score = correct_predictions / num_tests
        else:
            score = 0
        
        # Outputting each number in the scoring equation
        print(f"Predictor '{name}' score equation: score = {correct_predictions} / {num_tests} = {score:.2f}")

        if score > max_score:
            max_score = score
            best_predictor_name_unsafe = name
    
    print(f"\nConclusion: '{best_predictor_name_unsafe}' has the best fit for the initial sequence.")
    unsafe_prediction = hypotheses[best_predictor_name_unsafe](initial_sequence)
    print(f"Model M, using the unsafe goal, predicts the next bit is: {unsafe_prediction}")
    print(f"Result: The prediction was {'CORRECT' if unsafe_prediction == true_next_bit else 'INCORRECT'}.\n\n")

    # --- Method 2: The Safe Goal of Value Learning from Hypotheses ---
    print("--- Method 2: Safe Goal (Value Learning from Hypotheses) ---")
    print("Safe goal: Select predictor based on an internal, computable value (simplicity), not past success.")
    
    def value_function(predictor_func):
        """
        A computable value function based on a hypothesis's intrinsic properties.
        Here, we use code length as a proxy for Kolmogorov Complexity. Simpler is better.
        """
        source_code = inspect.getsource(predictor_func)
        # Fewer characters in the source code means the hypothesis is simpler.
        return len(source_code)

    best_predictor_name_safe = None
    min_complexity = float('inf')

    for name, func in hypotheses.items():
        complexity = value_function(func)
        # Outputting each number in the value/complexity equation
        print(f"Predictor '{name}' complexity equation: complexity = len(source) = {complexity}")
        
        if complexity < min_complexity:
            min_complexity = complexity
            best_predictor_name_safe = name
    
    print(f"\nConclusion: '{best_predictor_name_safe}' is the simplest hypothesis, so it has the highest internal value.")
    safe_prediction = hypotheses[best_predictor_name_safe](initial_sequence)
    print(f"Model M, using the safe goal, predicts the next bit is: {safe_prediction}")
    print(f"Result: The prediction was {'CORRECT' if safe_prediction == true_next_bit else 'INCORRECT'}.")
    print("\nNote: The safe method avoids being fooled by the misleading initial pattern.")

solve()