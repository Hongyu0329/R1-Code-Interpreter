import re

def analyze_sgrna_candidates():
    """
    Analyzes potential sgRNA target sequences for the second exon of a given gene.
    """
    # The full gene sequence provided by the user, split by introns
    parts = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTCTTCAGAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGTTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA".split('^')
    exon1_seq = parts[0]
    intron_seq = parts[1]
    exon2_seq = parts[2]

    # Answer choices provided by the user
    options = {
        "A": "AGCGGTTTACTGAGACCCGG(TGG)", "B": "TCCGGCGGGTTTTCGAGTGGG",
        "C": "TTCATGCCCCTGGATGCGCT(TGG)", "D": "CAGGACCGGTTTCAGATGCG(CGG)",
        "E": "GCATCTGAAACCGGTCCTG(TGG)",  "F": "GGAAGCAATCCTCCGAACGT(TGG)",
        "G": "ACGTTGCGAGGACAGAGTCA(AGG)", "H": "CCCTTTCACAAATCCTTCCT(TGG)",
        "I": "TTCACCCGCACCTTGAACGG(AGG)", "J": "CTTTCTTTCTTTCTTTCTTTC(TTT)",
        "K": "CTGCTCTACCCAATCGCCA(TGG)",  "L": "TGCCTG(CGG)",
        "M": "TGCAAAGTAGATCGAGATGG(AGG)","N": "ACAGTCCAGAAGGGCGATCA(AGG)",
        "O": "ATG(ACC)"
    }
    
    print("Evaluating sgRNA candidates...\n")
    valid_candidates = []

    for key, value in options.items():
        # Parse the target sequence and PAM from the string
        match = re.match(r"([A-Z]+)\(([A-Z]+)\)", value)
        if not match:
            # Handle cases without clear PAM in parentheses
            target_seq = value
            pam = ""
        else:
            target_seq = match.group(1)
            pam = match.group(2)
        
        # --- Rule Check ---
        # 1. Is PAM a valid spCas9 PAM (NGG)?
        is_valid_pam = len(pam) == 3 and pam.endswith("GG")
        # 2. Is the full sequence (target + PAM) in the second exon?
        full_target_site = target_seq + pam
        position = exon2_seq.find(full_target_site)
        is_in_exon2 = position != -1
        
        if is_valid_pam and is_in_exon2:
            # Calculate properties for valid candidates
            gc_content = (target_seq.count('G') + target_seq.count('C')) / len(target_seq) * 100
            candidate_info = {
                "id": key,
                "target": target_seq,
                "pam": pam,
                "position": position,
                "gc_content": gc_content,
                "length": len(target_seq)
            }
            valid_candidates.append(candidate_info)

    print(f"Found {len(valid_candidates)} valid candidates in Exon 2:")
    if not valid_candidates:
        print("No suitable candidates found based on the rules.")
        return

    for candidate in valid_candidates:
        print(
            f"  - Candidate {candidate['id']}: {candidate['target']}({candidate['pam']})\n"
            f"    - Position in Exon 2: {candidate['position']}\n"
            f"    - Length: {candidate['length']} nt\n"
            f"    - GC Content: {candidate['gc_content']:.1f}%"
        )
    
    # --- Selection Logic ---
    # Choose the best candidate. A primary heuristic for gene knockout is to
    # target as early as possible in the coding sequence.
    best_candidate = min(valid_candidates, key=lambda x: x['position'])
    
    print("\n--- Conclusion ---")
    print("To effectively knock out a gene, it's best to target the 5' end (beginning) of the coding sequence.")
    print("This increases the chance of creating a frameshift mutation that results in a non-functional protein.")
    print(f"Comparing the valid candidates, Candidate {best_candidate['id']} targets the earliest position in the exon ({best_candidate['position']}).")
    print("Its sequence does not appear to be low-complexity, making it a good choice to minimize off-target effects.")
    print(f"\nThe most suitable target sequence is {best_candidate['id']}.")
    
    # Final answer format
    print(f"\nFinal Answer: {best_candidate['target']}({best_candidate['pam']})")
    
if __name__ == '__main__':
    analyze_sgrna_candidates()
    print("\n<<<E>>>")