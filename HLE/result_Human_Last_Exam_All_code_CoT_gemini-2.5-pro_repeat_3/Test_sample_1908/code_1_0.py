import itertools

def get_powerset(s):
    """Generates the power set of a given set."""
    s_list = list(s)
    return frozenset(
        frozenset(c) for i in range(len(s_list) + 1) for c in itertools.combinations(s_list, i)
    )

def generate_topology_from_subbasis(X, subbasis):
    """Generates a topology from a subbasis."""
    # Step 1: Create a basis by taking all finite intersections of subbasis elements
    basis = set(subbasis)
    # Add the whole set X to the basis, as it's the intersection of zero subbasis elements
    basis.add(X)
    
    new_intersections_found = True
    while new_intersections_found:
        new_intersections_found = False
        current_basis = set(basis)
        for b1 in current_basis:
            for b2 in current_basis:
                intersection = b1.intersection(b2)
                if intersection not in basis:
                    basis.add(intersection)
                    new_intersections_found = True
    
    # Step 2: Create the topology by taking all possible unions of basis elements
    topology = set()
    for i in range(len(basis) + 1):
        for basis_subset in itertools.combinations(basis, i):
            union = frozenset().union(*basis_subset)
            topology.add(union)
            
    return frozenset(topology)

def check_complement(T, S, X):
    """Checks if S is a complement to T."""
    # Condition 1: Intersection is trivial
    is_trivial_intersection = T.intersection(S) == {frozenset(), X}
    
    # Condition 2: Union generates the discrete topology
    subbasis_for_discrete = T.union(S)
    generated_topology = generate_topology_from_subbasis(X, subbasis_for_discrete)
    discrete_topology = get_powerset(X)
    generates_discrete = generated_topology == discrete_topology
    
    return is_trivial_intersection and generates_discrete

def main():
    """
    Demonstrates that a topology can have at least two complements.
    """
    X = frozenset({0, 1, 2, 3})
    A = frozenset({0, 1})
    B = frozenset({2, 3})

    print(f"Set X = {set(X)}")
    print(f"Partition A = {set(A)}, B = {set(B)}")
    print("-" * 20)

    # Define the topology T_A = {U | A is a subset of U} U {emptyset}
    T_A = {u for u in get_powerset(X) if A.issubset(u)}.union({frozenset()})
    T_A = frozenset(T_A)
    print(f"Let's define a topology T_A based on A.")
    # print(f"T_A = {{ {', '.join(map(str,s))} }} for s in T_A}")
    
    # --- First Complement: S_B ---
    S_B = {u for u in get_powerset(X) if B.issubset(u)}.union({frozenset()})
    S_B = frozenset(S_B)
    print("\nCandidate Complement 1: S_B, based on B.")
    
    is_complement1 = check_complement(T_A, S_B, X)
    print(f"Is S_B a complement to T_A? {is_complement1}")
    
    # --- Second Complement: S' ---
    # f: A -> B is f(0)=2, f(1)=3
    # Subbasis for S' is {B, {0, f(0)}, {1, f(1)}}
    subbasis_S_prime = {
        B,
        frozenset({0, 2}),
        frozenset({1, 3})
    }
    S_prime = generate_topology_from_subbasis(X, subbasis_S_prime)
    print("\nCandidate Complement 2: S', generated by a different construction.")
    
    is_complement2 = check_complement(T_A, S_prime, X)
    print(f"Is S' a complement to T_A? {is_complement2}")

    print("-" * 20)
    # Check if the two complements are actually different topologies
    are_different = S_B != S_prime
    print(f"Are the two found complements S_B and S' different? {are_different}")

    if is_complement1 and is_complement2 and are_different:
        print("\nWe have found a topology T_A that has at least two distinct complements.")
        print("Since topologies with exactly two complements are known to exist, and we've shown it's possible to have more than one, the smallest possible number of complements is 2.")
    else:
        print("\nCould not demonstrate that the minimum is 2.")

    # The final answer is the number 2.
    final_answer = 2
    print(f"\nThe smallest possible number of complements is {final_answer}.")
    
if __name__ == "__main__":
    main()