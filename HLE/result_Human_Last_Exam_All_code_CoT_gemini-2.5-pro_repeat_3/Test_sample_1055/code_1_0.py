import numpy as np

# Set G to be the group SL_2(Z).
print("Let G be the group SL_2(Z).")
# The subgroup H is generated by matrices a and b.
a = np.array([[-21, 242], [-2, 23]])
b = np.array([[-19, 200], [-2, 21]])

print("Let H be the subgroup generated by a and b:")
print("a =\n", a)
print("b =\n", b)

# Step 1: Verify that a and b are in SL_2(Z).
det_a = int(np.round(np.linalg.det(a)))
det_b = int(np.round(np.linalg.det(b)))
print(f"\nFirst, we check that a and b are in G by computing their determinants.")
print(f"det(a) = (-21)*(23) - (242)*(-2) = -483 + 484 = {det_a}")
print(f"det(b) = (-19)*(21) - (200)*(-2) = -399 + 400 = {det_b}")
print("Since the determinants are 1, both matrices are in SL_2(Z).")

# Step 2: Compute the traces.
tr_a = int(np.trace(a))
tr_b = int(np.trace(b))
print(f"\nNext, we compute the traces of a and b.")
print(f"tr(a) = -21 + 23 = {tr_a}")
print(f"tr(b) = -19 + 21 = {tr_b}")
print("Since their traces are 2, both a and b are parabolic elements.")

# Step 3: Find the conjugating matrices.
print("\nParabolic elements in SL_2(Z) with trace 2 are conjugate to a matrix of the form [[1, k], [0, 1]].")
print("To find the conjugating matrix, we first find the eigenvector for the eigenvalue 1.")
print("For a, we solve (a - I)v = 0, which is [[-22, 242], [-2, 22]]v = 0. This gives the eigenvector v_a = [11, 1]^T.")
print("For b, we solve (b - I)v = 0, which is [[-20, 200], [-2, 20]]v = 0. This gives the eigenvector v_b = [10, 1]^T.")

# Step 4: Construct conjugating matrices P_a and P_b from the eigenvectors.
# P_a must have v_a as its first column and have determinant 1.
# P_a = [[11, k], [1, l]]. 11*l - k = 1. We can choose l=1, k=10.
P_a = np.array([[11, 10], [1, 1]])
# P_b must have v_b as its first column and have determinant 1.
# P_b = [[10, k], [1, l]]. 10*l - k = 1. We can choose l=1, k=9.
P_b = np.array([[10, 9], [1, 1]])
print("\nWe construct conjugating matrices P_a and P_b with these eigenvectors:")
print("P_a =\n", P_a)
print("P_b =\n", P_b)

# Step 5: Verify the conjugation.
P_a_inv = np.linalg.inv(P_a).astype(int)
P_b_inv = np.linalg.inv(P_b).astype(int)
U_a = P_a_inv @ a @ P_a
U_b = P_b_inv @ b @ P_b
print("\nNow we conjugate a and b by these matrices:")
print("U = P_a^{-1} * a * P_a =\n", U_a)
print("U = P_b^{-1} * b * P_b =\n", U_b)
U = U_a

# Step 6: Determine the conjugate subgroup H'.
print("\nSince a = P_a * U * P_a^{-1} and b = P_b * U * P_b^{-1}, the subgroup H = <a, b> is conjugate to H' = <U, C*U*C^{-1}>, where C = P_a^{-1} * P_b.")
C = P_a_inv @ P_b
print("C = P_a^{-1} * P_b =\n", C)

C_inv = np.linalg.inv(C).astype(int)
gen2_H_prime = C @ U @ C_inv
print("The second generator of H' is C * U * C^{-1} =\n", gen2_H_prime)

# Step 7: Identify H'.
V_inv = gen2_H_prime
V = np.linalg.inv(V_inv).astype(int)
print("This matrix is the inverse of V =\n", V)
print("\nSo, H is conjugate to H' = <U, V^{-1}>, where U = [[1, 2], [0, 1]] and V = [[1, 0], [2, 1]].")
print("U and V are the standard generators for the principal congruence subgroup Gamma(2).")
print("Therefore, H is a conjugate of Gamma(2), and [G : H] = [G : Gamma(2)].")

# Step 8: Compute the index.
print("\nThe index [G : Gamma(2)] is the order of the group SL_2(Z/2Z).")
order_sl2_z2 = 6 # Can be computed as p*(p^2-1) for p=2, which is 2*(4-1) = 6.
print(f"The order of SL_2(Z/2Z) is {order_sl2_z2}.")
print(f"\nFinal Answer: The index [G : H] is {order_sl2_z2}.")
