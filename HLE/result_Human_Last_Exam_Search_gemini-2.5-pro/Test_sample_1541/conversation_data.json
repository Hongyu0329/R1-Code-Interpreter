{
  "question": "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>.",
  "response_list": [
    "This problem requires rearranging the numbers in a given sum string (e.g., \"3+1+4+1+2\") into non-decreasing order (e.g., \"1+1+2+3+4\"). The most memory-efficient approach avoids creating a large array to store the numbers. Instead, we can use a \"counting sort\" method, which is ideal since the set of possible numbers (1, 2, 3, 4) is very small.\n\nThe strategy is as follows:\n1.  Read the entire input string into a character array.\n2.  Create a small integer array (e.g., `counts`) to act as a frequency map. `counts[0]` will store the number of 1s, `counts[1]` the number of 2s, and so on.\n3.  Iterate through the input string. When a digit is encountered, increment the corresponding counter in the `counts` array.\n4.  Finally, construct the output string by iterating through the `counts` array. Print each number the required number of times, separated by '+' characters.\n\nThis method only requires memory for the input string and a small, fixed-size array for the counts, making it highly memory-efficient.\n\n### Memory Calculation (m)\n\nThe total memory `m` is the sum of the memory allocated for all variables in the program. We assume a standard environment where `char` is 1 byte and `int` is 4 bytes.\n\n*   **Input String Buffer**: The problem states the string `s` is at most 1000 characters long. To store this and the null terminator (`\\0`), we need an array of size 1001.\n    *   `char s[1001];` -> 1001 * `sizeof(char)` = **1001 bytes**\n*   **Counters for Numbers**: The sum contains numbers 1, 2, 3, and 4. We need an integer array of size 4 to store their counts.\n    *   `int counts[4];` -> 4 * `sizeof(int)` = 4 * 4 = **16 bytes**\n*   **Loop Counter**: A standard integer variable for loops.\n    *   `int i;` -> 1 * `sizeof(int)` = **4 bytes**\n*   **Printing Flag**: An integer flag to manage the printing of the `+` symbol.\n    *   `int first_term;` -> 1 * `sizeof(int)` = **4 bytes**\n\n**Total Memory (m)** = 1001 + 16 + 4 + 4 = **1025 bytes**.\n\n### Most Memory-Efficient C Program\n\n```c\n#include <stdio.h>\n\n/**\n * This program solves the Xenia and the beginner mathematician problem\n * by rearranging a sum of numbers (1, 2, 3, 4) into non-decreasing order.\n * It uses a memory-efficient counting sort algorithm.\n */\nint main() {\n    // Per the prompt, the string is at most 1000 characters long.\n    // We need 1001 bytes for the string and the null terminator.\n    char s[1001];\n\n    // Per the prompt, the sum contains numbers 1, 2, 3, and 4.\n    // counts[0] for '1's, counts[1] for '2's, etc.\n    int counts[4] = {0};\n\n    // A loop counter variable.\n    int i;\n\n    // A flag to handle printing the '+' sign correctly.\n    // It is initialized to 1 (true) and set to 0 (false) after the first number is printed.\n    int first_term = 1;\n\n    // Read the input sum from the user.\n    scanf(\"%s\", s);\n\n    // Count the occurrences of each number (1, 2, 3, 4).\n    // We iterate through the string and only check the digits, ignoring '+'.\n    for (i = 0; s[i] != '\\0'; i++) {\n        if (s[i] == '1') {\n            counts[0]++;\n        } else if (s[i] == '2') {\n            counts[1]++;\n        } else if (s[i] == '3') {\n            counts[2]++;\n        } else if (s[i] == '4') {\n            counts[3]++;\n        }\n    }\n\n    // Print the sorted sum by iterating through the number counts.\n    // This approach avoids creating a large secondary array to sort.\n\n    // Print all the '1's\n    for (i = 0; i < counts[0]; i++) {\n        if (!first_term) {\n            printf(\"+\");\n        }\n        printf(\"1\");\n        first_term = 0;\n    }\n    // Print all the '2's\n    for (i = 0; i < counts[1]; i++) {\n        if (!first_term) {\n            printf(\"+\");\n        }\n        printf(\"2\");\n        first_term = 0;\n    }\n    // Print all the '3's\n    for (i = 0; i < counts[2]; i++) {\n        if (!first_term) {\n            printf(\"+\");\n        }\n        printf(\"3\");\n        first_term = 0;\n    }\n    // Print all the '4's\n    for (i = 0; i < counts[3]; i++) {\n        if (!first_term) {\n            printf(\"+\");\n        }\n        printf(\"4\");\n        first_term = 0;\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n<<<1025>>>"
  ],
  "user_prompt_list": [
    "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>."
  ],
  "system_message": ""
}