import re

def get_reverse_complement(seq):
    """Returns the reverse complement of a DNA sequence."""
    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
    return "".join(complement.get(base, 'N') for base in reversed(seq))

def analyze_sgRNA_options():
    """
    Analyzes potential sgRNA targets against a gene sequence to find the most suitable one.
    """
    full_sequence = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTTCAAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGTTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"
    parts = full_sequence.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]
    
    options = {
        'A': 'AGCGGTTTACTGAGACCCGG(TGG)', 'B': 'TCCGGCGGGTTTTCGAGTGGG',
        'C': 'TTCATGCCCCTGGATGCGCT(TGG)', 'D': 'CAGGACCGGTTTCAGATGCG(CGG)',
        'E': 'GCATCTGAAACCGGTCCTG(TGG)', 'F': 'GGAAGCAATCCTCCGAACGT(TGG)',
        'G': 'ACGTTGCGAGGACAGAGTCA(AGG)', 'H': 'CCCTTTCACAAATCCTTCCT(TGG)',
        'I': 'TTCACCCGCACCTTGAACGG(AGG)', 'J': 'CTTTCTTTCTTTCTTTCTTTC(TTT)',
        'K': 'CTGCTCTACCCAATCGCCA(TGG)', 'L': 'TGCCTG(CGG)',
        'M': 'TGCAAAGTAGATCGAGATGG(AGG)', 'N': 'ACAGTCCAGAAGGGCGATCA(AGG)',
        'O': 'ATG(ACC)'
    }

    print("--- Analysis of sgRNA Candidates ---")
    results = {}
    for key, val in options.items():
        match = re.match(r'([A-Z]+)\(([A-Z]+)\)', val)
        if match:
            target, pam = match.groups()
        else: # Handle improperly formatted options
            target, pam = val, "N/A"

        # Rule out based on invalid length or properties
        if not (18 <= len(target) <= 22):
            results[key] = "INVALID: Target length is not suitable."
            continue
        if "CTTTCTTTC" in target:
            results[key] = "INVALID: Highly repetitive, high off-target risk. Targets intron."
            continue
        
        # Check direct match (target on coding strand)
        search_seq = target + pam
        if search_seq in exon2:
            results[key] = "VALID: Found directly in Exon 2 with matching PAM."
            continue

        # Check reverse complement match (target on template strand)
        rev_comp_target = get_reverse_complement(target)
        pos = exon2.find(rev_comp_target)
        if pos != -1:
            actual_pam = exon2[pos + len(rev_comp_target) : pos + len(rev_comp_target) + 3]
            if actual_pam.endswith('GG'):
                results[key] = f"VALID: Found on template strand in Exon 2 with actual PAM({actual_pam}). Stated PAM({pam}) is incorrect."
                continue

        # Check location if not in exon 2
        if target in exon1 or (get_reverse_complement(target) in exon1):
            results[key] = "INVALID: Targets Exon 1."
        elif target in intron or (get_reverse_complement(target) in intron):
            results[key] = "INVALID: Targets intron."
        else:
            results[key] = "INVALID: Target not found in the provided gene sequence."
    
    for key, result in sorted(results.items()):
        print(f"Option {key}: {result}")

    print("\n--- Conclusion ---")
    print("Option E is the most suitable target. The sequence 'GCATCTGAAACCGGTCCTG' is found directly in Exon 2 and is followed by the correctly specified PAM 'TGG'.")

    final_target = "GCATCTGAAACCGGTCCTG"
    final_pam = "TGG"
    
    print("\nFinal Target Sequence Breakdown:")
    # Create the requested output format: each letter separated by a space
    spaced_target = " ".join(final_target)
    final_equation = f"{spaced_target}({final_pam})"
    
    print(final_equation)
    print("\n<<<E>>>")

analyze_sgRNA_options()