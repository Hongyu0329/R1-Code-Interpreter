def solve_sequence():
    """
    Solves the sequence puzzle by identifying and extrapolating its underlying patterns.

    The sequence is built from runs of numbers.
    - The sequence of run *values* follows a "bouncing" pattern: 3, 2, 1, 2, 3, 2, 1, ...
    - The sequence of run *lengths* follows its own pattern: 1, 1, 1, 1, 3, 3, 3, ...

    This code generates the full sequence based on these two rules and determines the next
    four elements after the given prefix.
    """
    
    # The given prefix of the sequence
    given_sequence_str = "3 2 1 2 3 3 3 2 2"
    given_sequence = [int(x) for x in given_sequence_str.split()]

    # Rule for run values: bounces between 3 and 1
    s_val = []
    current_val = 3
    direction = -1
    for _ in range(10): # Generate a long enough sequence of values
        s_val.append(current_val)
        if current_val == 1:
            direction = 1
        elif current_val == 3:
            direction = -1
        current_val += direction

    # Rule for run lengths: four 1s, then three 3s, etc.
    s_len = [1, 1, 1, 1, 3, 3, 3, 3, 3, 3] # Use enough 3s to be safe

    # Generate the full sequence from the rules
    full_sequence = []
    for val, length in zip(s_val, s_len):
        for _ in range(length):
            full_sequence.append(val)

    # Find the next 4 elements after the given sequence
    start_index = len(given_sequence)
    next_4_elements = full_sequence[start_index : start_index + 4]
    
    # Print the explanation and the final result
    print("The original sequence is: 3 2 1 2 3 3 3 2 2")
    print("The pattern is based on run-length encoding with two rules:")
    print("1. Run values bounce between 3 and 1: 3, 2, 1, 2, 3, 2, 1, ...")
    print("2. Run lengths follow a pattern: 1, 1, 1, 1, 3, 3, 3, ...")
    print("The full sequence generated by these rules starts: 3 2 1 2 3 3 3 2 2 2 1 1 1 ...")
    print("The given sequence is a prefix of this full sequence.")
    print("The elements immediately following the given sequence are:")
    # Using print with multiple arguments automatically adds spaces
    print(*next_4_elements)

solve_sequence()
<<<A>>>