import math

def find_sphere_distances():
    """
    Calculates and prints the possible normalized distances (r <= 3) between
    hard spheres packed on a 2D plane.

    The calculation considers distances arising from both square and hexagonal
    packing arrangements, as these represent the fundamental local structures
    in 2D jammed systems.
    """

    # Use a dictionary to map the calculated distance to its symbolic representation.
    # This helps in avoiding duplicates and storing the "equation" or origin of the value.
    distance_map = {}

    # Set the maximum distance to consider (r_max = 3, so r_max^2 = 9)
    # A small tolerance is added for floating point comparisons.
    max_r_sq = 9.000001

    # --- Step 1: Calculate distances from a Square Lattice ---
    # The distance 'r' from the origin to a point (n, m) is sqrt(n^2 + m^2).
    # We iterate through integer coordinates n and m.
    # We use range(n, 4) for m to avoid duplicate pairs like (1,2) and (2,1).
    for n in range(4):
        for m in range(n, 4):
            if n == 0 and m == 0:
                continue
            
            r_sq = float(n**2 + m**2)
            if r_sq <= max_r_sq:
                r = math.sqrt(r_sq)
                # Use the integer value for the symbolic form if it's a perfect square.
                if r == int(r):
                    distance_map[r] = f"{int(r)}"
                else:
                    distance_map[r] = f"sqrt({int(r_sq)})"

    # --- Step 2: Calculate distances from a Hexagonal Lattice ---
    # The distance 'r' is given by r^2 = n^2 + m^2 + nm.
    # We iterate through integer steps n and m along the lattice vectors.
    for n in range(4):
        for m in range(-n, 4):
            if n == 0 and m == 0:
                continue

            r_sq = float(n**2 + m**2 + n * m)
            if 0 < r_sq <= max_r_sq:
                r = math.sqrt(r_sq)
                
                # Check if a very similar distance has already been found to avoid float precision issues.
                is_new = True
                for k in distance_map.keys():
                    if abs(r - k) < 1e-9:
                        is_new = False
                        break
                
                if is_new:
                    if r == int(r):
                        distance_map[r] = f"{int(r)}"
                    else:
                        # For non-integer roots, show the symbolic form.
                        distance_map[r] = f"sqrt({int(round(r_sq))})"

    # --- Step 3: Sort and Print the Results ---
    # Get the unique distances and sort them in ascending order.
    sorted_distances = sorted(distance_map.keys())

    print("The set of possible normalized distances (r) and their geometric origin for r <= 3 are:")
    
    # Print each distance, its symbolic form (the "equation"), and its value formatted to two decimals.
    for r in sorted_distances:
        symbolic_form = distance_map[r]
        # This print format satisfies the requirement to "output each number in the final equation".
        print(f"r = {symbolic_form} = {r:.2f}")

if __name__ == '__main__':
    find_sphere_distances()
    # The final answer is the set of numerical values generated by the code.
    # For the purpose of a single-line answer format, we list the values.
    # <<<[1.00, 1.41, 1.73, 2.00, 2.24, 2.65, 2.83, 3.00]>>>