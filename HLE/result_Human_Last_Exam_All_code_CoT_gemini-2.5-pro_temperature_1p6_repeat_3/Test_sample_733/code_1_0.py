import itertools

def define_groups():
    """
    Defines a list of common finite groups of small order.
    Each group is represented as a dictionary with its name, a list of its elements
    (represented by integers 0 to n-1), and its multiplication table.
    """
    groups = []

    # Cyclic groups Z_n (additive group modulo n) for n from 2 to 6
    for n in range(2, 7):
        group = {'name': f'Z_{n}', 'elements': list(range(n))}
        mul_table = {}
        for i in range(n):
            for j in range(n):
                mul_table[(i, j)] = (i + j) % n
        group['mul_table'] = mul_table
        groups.append(group)
        
    # Z_2 x Z_2 (Klein four-group, V4)
    v4 = {'name': 'Z_2xZ_2', 'elements': list(range(4))}
    v4['mul_table'] = {
        (0,0):0, (0,1):1, (0,2):2, (0,3):3,
        (1,0):1, (1,1):0, (1,2):3, (1,3):2,
        (2,0):2, (2,1):3, (2,2):0, (2,3):1,
        (3,0):3, (3,1):2, (3,2):1, (3,3):0
    }
    groups.append(v4)
    
    # Dihedral group D_8 (symmetries of a square)
    # Generated by r (rotation) and s (reflection) such that r^4=s^2=e, sr=r^3s
    # Elements map: r^i s^j -> 4*j + i
    # e=0, r=1, r^2=2, r^3=3, s=4, rs=5, r^2s=6, r^3s=7
    d8 = {'name': 'D_8', 'elements': list(range(8))}
    d8_mul_table = {}
    for i1 in range(4):
        for j1 in range(2):
            for i2 in range(4):
                for j2 in range(2):
                    e1_idx = 4 * j1 + i1
                    e2_idx = 4 * j2 + i2
                    if j1 == 0:
                        res_i = (i1 + i2) % 4
                        res_j = (j1 + j2) % 2
                    else: # j1 == 1
                        res_i = (i1 - i2) % 4
                        res_j = (j1 + j2) % 2
                    res_idx = 4 * res_j + res_i
                    d8_mul_table[(e1_idx, e2_idx)] = res_idx
    d8['mul_table'] = d8_mul_table
    groups.append(d8)

    # Quaternion group Q_8
    # Elements map: 1=0, -1=1, i=2, -i=3, j=4, -j=5, k=6, -k=7
    q8 = {'name': 'Q_8', 'elements': list(range(8))}
    q8_table = [
        [0,1,2,3,4,5,6,7], [1,0,3,2,5,4,7,6], [2,3,1,0,6,7,5,4], [3,2,0,1,7,6,4,5],
        [4,5,7,6,1,0,2,3], [5,4,6,7,0,1,3,2], [6,7,4,5,3,2,1,0], [7,6,5,4,2,3,0,1]
    ]
    q8_mul_table = {}
    for r in range(8):
        for c in range(8):
            q8_mul_table[(r, c)] = q8_table[r][c]
    q8['mul_table'] = q8_mul_table
    groups.append(q8)
    
    return groups

def has_maximal_product_free_set_of_size_2(group_def):
    """Checks if a given group has a maximal product-free set of size 2."""
    elements = group_def['elements']
    mul_table = group_def['mul_table']
    
    # Iterate over all subsets of size 2
    for s_tuple in itertools.combinations(elements, 2):
        s_set = set(s_tuple)

        # 1. Check if S is product-free
        is_pf = True
        for x in s_set:
            for y in s_set:
                if mul_table[(x, y)] in s_set:
                    is_pf = False
                    break
            if not is_pf: break
        
        if not is_pf:
            continue

        # 2. If product-free, check for maximality
        is_maximal = True
        g_minus_s = [g for g in elements if g not in s_set]
        for g in g_minus_s:
            s_prime_set = s_set.union({g})
            
            # Check if S' = S U {g} is still product-free.
            # If it is, then S was not maximal.
            found_product_in_s_prime = False
            for x in s_prime_set:
                for y in s_prime_set:
                    if mul_table[(x, y)] in s_prime_set:
                       found_product_in_s_prime = True
                       break
                if found_product_in_s_prime: break
            
            if not found_product_in_s_prime:
                is_maximal = False
                break 

        if is_maximal:
            return True
            
    return False

def solve():
    """
    Finds and counts the number of finite groups from a predefined list
    that contain a maximal by inclusion product-free set of size 2.
    """
    count = 0
    all_groups = define_groups()
    for group in all_groups:
        if has_maximal_product_free_set_of_size_2(group):
            count += 1
            
    print(count)

solve()