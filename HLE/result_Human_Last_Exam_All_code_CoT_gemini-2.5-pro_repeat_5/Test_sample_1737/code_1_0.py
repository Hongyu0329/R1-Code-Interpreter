import math
from fractions import Fraction

def solve_su_n_d_values():
    """
    Calculates the number of different numerical values for the non-zero
    totally symmetric structure constants d_ijk of SU(N).
    """
    try:
        N_str = input("Enter the value of N for SU(N): ")
        N = int(N_str)
    except (ValueError, EOFError):
        print("Invalid input. Please enter an integer.")
        return

    if N < 2:
        print("For N < 2, the group SU(N) is trivial and has no generators.")
        print("Number of distinct non-zero d_ijk values: 0")
        return

    if N == 2:
        print("For SU(2), all d_ijk constants are zero.")
        print("Number of distinct non-zero d_ijk values: 0")
        return

    # For N >= 3, we compute the values.
    # The values are stored as (sign, value^2) to handle irrational numbers precisely.
    # value^2 is stored as a Fraction object.
    distinct_values = set()

    # The non-zero values of d_ijk arise from couplings involving the
    # N-1 diagonal generators (Cartan subalgebra), which we denote H_l.
    # A standard choice for these generators (normalized Tr(H^2)=1/2) is:
    # H_l = C_l * diag(1, ..., 1, -l, 0, ..., 0)
    # where there are l ones, and C_l = 1 / sqrt(2*l*(l+1)).

    for l in range(1, N):
        # Cl_sq is the squared normalization constant C_l^2
        Cl_sq = Fraction(1, 2 * l * (l + 1))

        # Build the diagonal of H_l without the normalization constant
        diag_elements_num = []
        for i in range(1, N + 1):
            if i <= l:
                diag_elements_num.append(1)
            elif i == l + 1:
                diag_elements_num.append(-l)
            else:
                diag_elements_num.append(0)

        # Type 1: Values from d_iik = (H_k)_mm + (H_k)_nn
        for m_idx in range(N):
            for n_idx in range(m_idx + 1, N):
                # Numerator part of the value before multiplying by C_l
                val_sum_num = diag_elements_num[m_idx] + diag_elements_num[n_idx]
                if val_sum_num == 0:
                    continue
                
                # val^2 = (val_sum_num * C_l)^2 = val_sum_num^2 * C_l^2
                val_sq = val_sum_num**2 * Cl_sq
                sign = 1 if val_sum_num > 0 else -1
                distinct_values.add((sign, val_sq))

        # Type 2: Values from d_lll = 4 * Tr(H_l^3)
        # Numerator part of Tr(H_l^3) before multiplying C_l^3
        trace_cubed_num = l * (1**3) + 1 * ((-l)**3)
        if trace_cubed_num == 0:
            continue

        # d_lll = 4 * C_l^3 * trace_cubed_num
        # d_lll^2 = 16 * (C_l^2)^3 * trace_cubed_num^2
        val_trace_sq = 16 * (Cl_sq**3) * (trace_cubed_num**2)
        sign_trace = 1 if trace_cubed_num > 0 else -1
        distinct_values.add((sign_trace, val_trace_sq))
        
    # The type d_ijk for three off-diagonal generators gives values +-1/2,
    # which can be shown to be already generated by Type 1 for l=1.
    
    print(f"For SU({N}), the non-zero d_ijk constants take {len(distinct_values)} different numerical values.")

solve_su_n_d_values()