import itertools

def powerset(iterable):
    """
    Generates the powerset of an iterable.
    E.g., powerset([1,2]) --> () (1,) (2,) (1,2)
    """
    s = list(iterable)
    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))

# The schema S has k unary predicates. The problem states k=4.
# The logical fragment is FO_{exists, and, top, bot}[S].
#
# As explained in the thinking steps, any classifier from this logic is equivalent to
# a conjunction of some of the k predicates. This class of classifiers is called
# "monotone monomials". The VC dimension of this class is k.
#
# We will demonstrate this for k=4.

k = 4  # Number of unary predicates

print(f"Let k = {k} be the number of unary predicates in schema S.")
print("The hypothesis class defined by FO_{exists, and, top, bot}[S] corresponds to conjunctions of these k predicates.")
print("The VC dimension of this class is k.")
print("We will demonstrate this by showing VCdim >= k and VCdim <= k.")
print("-" * 20)

# --------------------------------------------------------------------------
# Part 1: Show VC dimension >= k
# --------------------------------------------------------------------------
print(f"Part 1: Show VC dimension is at least {k}")
print(f"We prove this by showing that a set of {k} points can be shattered.")
print("We need to define a model (i.e., interpret the predicates) and a set of points X.")

# Let X be a set of k points. We can name them 1, 2, ..., k.
X = set(range(1, k + 1))
print(f"\nLet X be the set of points: {X}")

# We define the interpretations of the k predicates, S_1, ..., S_k.
# The construction is: let S_i be the set of all points in X except for point i.
predicates = []
print("Let the k predicates P_i be interpreted as sets S_i as follows:")
for i in range(1, k + 1):
    s_i = X - {i}
    predicates.append(s_i)
    print(f"  P_{i} is interpreted as S_{i} = {s_i}")

print("\nNow, we must check if X can be shattered.")
print("This means for any subset Y of X, we must find a hypothesis that picks out exactly Y.")
# A hypothesis is a conjunction of predicates. It corresponds to an intersection of the sets S_i.

shattered = True
num_subsets = 2**k
# Iterate over all possible subsets Y of X
for Y_tuple in powerset(X):
    Y = set(Y_tuple)
    
    # For each Y, we must find a hypothesis (a conjunction of predicates) that generates it.
    # The rule is: to generate Y, intersect the sets S_i for all i where point x_i is NOT in Y.
    I = {i for i in X if i not in Y}
    
    # H_I is the set generated by the hypothesis.
    H_I = None
    if not I:
        # An empty conjunction is TRUE, so it defines the universal set, which is X here.
        H_I = X
    else:
        # Intersect all sets S_i for i in I.
        # We start with a copy of one of the sets to avoid modifying the original list.
        H_I = predicates[list(I)[0] - 1].copy()
        for i in I:
            H_I.intersection_update(predicates[i - 1])

    # Check if the generated set H_I is identical to the target subset Y.
    if H_I != Y:
        print(f"\n[FAIL] Failed to generate subset Y = {Y}")
        print(f"       Using the rule, required intersecting predicates with indices I = {I}")
        print(f"       This produced the set {H_I}, which is not correct.")
        shattered = False
        break

if shattered:
    print(f"\n[SUCCESS] All {num_subsets} subsets of X were successfully generated.")
    print(f"This proves that the set X of size {k} can be shattered.")
    print(f"Therefore, the VC dimension is at least {k}.")
else:
    print("\n[FAIL] The construction failed. The set was not shattered.")

print("-" * 20)

# --------------------------------------------------------------------------
# Part 2: Show VC dimension <= k
# --------------------------------------------------------------------------
print(f"Part 2: Show VC dimension is at most {k}")
print("This part of the argument relies on a simple counting argument.")

# The number of unique hypotheses is limited by the number of ways we can form a conjunction.
# We can choose any subset of the k predicates to include in the conjunction.
num_hypotheses = 2**k
print(f"\nWith {k} predicates, we can form 2^{k} = {num_hypotheses} distinct hypotheses (one for each subset of predicates).")

# Now, consider shattering a set of d = k + 1 points.
d = k + 1
num_subsets_to_shatter_d = 2**d
print(f"To shatter a set of {d} points, we would need to generate all 2^{d} = {num_subsets_to_shatter_d} of its subsets.")

print(f"\nWe need to generate {num_subsets_to_shatter_d} subsets, but our logic can only define at most {num_hypotheses} unique sets in any model.")

if num_hypotheses < num_subsets_to_shatter_d:
    print(f"Since {num_hypotheses} < {num_subsets_to_shatter_d}, it is impossible to shatter any set of {d} points.")
    print(f"This implies that the VC dimension must be less than {d}, i.e., VCdim <= {k}.")
else:
    # This case won't be reached for k>=0
    print("The counting argument does not preclude shattering {d} points.")
    
print("-" * 20)

# --------------------------------------------------------------------------
# Conclusion
# --------------------------------------------------------------------------
final_vc_dim = k
print("\nConclusion:")
print(f"From Part 1, we established that VC dimension >= {k}.")
print(f"From Part 2, we established that VC dimension <= {k}.")
print(f"\nCombining these two results, the VC dimension must be exactly {final_vc_dim}.")
print(f"The final equation is: VCdim = {final_vc_dim}")
