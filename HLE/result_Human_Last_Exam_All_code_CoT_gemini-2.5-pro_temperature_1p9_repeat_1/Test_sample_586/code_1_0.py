import re

def solve_sgrna_targeting():
    """
    This script analyzes potential sgRNA target sequences for the second exon of a gene,
    evaluates them based on CRISPR/spCas9 design principles, and selects the best option.
    """
    full_sequence = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTCAGAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGTTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"
    
    # 1. Isolate sequences
    parts = full_sequence.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]
    search_space = full_sequence.replace('^', '')

    candidates = {
        'A': 'AGCGGTTTACTGAGACCCGG(TGG)', 'B': 'TCCGGCGGGTTTTCGAGTGGG',
        'C': 'TTCATGCCCCTGGATGCGCT(TGG)', 'D': 'CAGGACCGGTTTCAGATGCG(CGG)',
        'E': 'GCATCTGAAACCGGTCCTG(TGG)', 'F': 'GGAAGCAATCCTCCGAACGT(TGG)',
        'G': 'ACGTTGCGAGGACAGAGTCA(AGG)', 'H': 'CCCTTTCACAAATCCTTCCT(TGG)',
        'I': 'TTCACCCGCACCTTGAACGG(AGG)', 'J': 'CTTTCTTTCTTTCTTTCTTTC(TTT)',
        'K': 'CTGCTCTACCCAATCGCCA(TGG)', 'L': 'TGCCTG(CGG)',
        'M': 'TGCAAAGTAGATCGAGATGG(AGG)', 'N': 'ACAGTCCAGAAGGGCGATCA(AGG)',
        'O': 'ATG(ACC)'
    }

    valid_candidates = {}

    for key, value in candidates.items():
        match = re.match(r"([ACGT]+)\s*\(([ACGT]{3})\)", value)
        if not match:
            continue
        
        target_seq, pam_seq = match.groups()
        
        # Rule check: Valid PAM (NGG)
        if not pam_seq.endswith('GG'):
            continue
            
        # Rule check: Target length (17-23 is a reasonable range)
        if not (17 <= len(target_seq) <= 23):
            continue
            
        full_site = target_seq + pam_seq
        
        # Rule check: Location (must be in Exon 2)
        if full_site in exon2:
            gc_count = target_seq.count('G') + target_seq.count('C')
            gc_percent = (gc_count / len(target_seq)) * 100
            
            # Quality check: off-targets in the provided sequence
            num_hits = search_space.count(target_seq)
            
            # Quality check: poly-T
            has_poly_t = 'TTTT' in target_seq
            
            valid_candidates[key] = {
                'target': target_seq,
                'pam': pam_seq,
                'gc': gc_percent,
                'hits': num_hits,
                'poly_t': has_poly_t
            }

    # 5. Select the best candidate
    best_candidate_key = None
    
    # Filter for candidates with 1 hit (ideal) and no poly-T tracts
    ideal_candidates = {k: v for k, v in valid_candidates.items() if v['hits'] == 1 and not v['poly_t']}

    if not ideal_candidates:
        print("No ideal candidates found (unique and no poly-T). Evaluating all valid options.")
        # Fallback to any valid candidate if none are ideal
        ideal_candidates = valid_candidates

    # Tie-break using GC content (closest to 50% is best)
    best_gc_score = float('inf')
    for key, data in ideal_candidates.items():
        gc_score = abs(data['gc'] - 50)
        if gc_score < best_gc_score:
            best_gc_score = gc_score
            best_candidate_key = key

    # Final Output
    print("--- Analysis Complete ---")
    if best_candidate_key:
        best_data = ideal_candidates[best_candidate_key]
        final_target = best_data['target']
        final_pam = best_data['pam']
        
        print(f"The most suitable sgRNA candidate is choice '{best_candidate_key}'.")
        print(f"It targets a sequence in Exon 2 that is unique in the provided DNA (1 hit).")
        print(f"It has a favorable GC content of {best_data['gc']:.1f}% and no problematic poly-T tracts.")
        print("\n--- Final Recommended Target ---")
        print("Equation Breakdown:")
        print(f"Target Sequence : {final_target}")
        print(f"PAM Sequence    : {final_pam}")
        print(f"Full Site       : {final_target + final_pam}")
        print(f"<<<{best_candidate_key}>>>")
    else:
        print("No suitable candidates were found in the options provided that target exon 2.")

solve_sgrna_targeting()