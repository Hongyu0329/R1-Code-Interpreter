import math

def solve_group_theory_problem():
    """
    This function solves the problem by following these steps:
    1.  Define the number of generators for A = A_5.
    2.  Define the formula for the number of generators of B_n = A^n.
    3.  Define the formula for the number of generators of C_n, the free product of 50 copies of B_n.
    4.  Solve the inequality d(C_n) <= 100 to find the largest integer n.
    5.  Print all steps of the calculation.
    """
    print("This script finds the largest integer n such that d(C_n) <= 100.")
    print("-" * 50)

    # Known values
    d_A = 2
    num_copies_in_C = 50
    d_C_max_limit = 100

    print("Step 1: Determine d(A), where A is the alternating group A_5.")
    print(f"A_5 is a non-abelian simple group, so it can be generated by 2 elements. Thus, d(A) = {d_A}.")
    print("-" * 50)

    print("Step 2: Determine d(B_n), where B_n is the direct product of n copies of A.")
    print("The formula is d(B_n) = max(d(A), ceil(log_|Out(A)|(n))).")
    print(f"For A=A_5, d(A)={d_A} and |Out(A_5)|=2. So, d(B_n) = max(2, ceil(log2(n))).")
    print("-" * 50)

    print("Step 3: Determine d(C_n), where C_n is the free product of 50 copies of B_n.")
    print("By the Grushko-Neumann theorem, d(C_n) = 50 * d(B_n).")
    print("Substituting the formula for d(B_n), we get: d(C_n) = 50 * max(2, ceil(log2(n))).")
    print("-" * 50)

    print(f"Step 4: Solve the inequality d(C_n) <= {d_C_max_limit}.")
    print(f"The inequality is: {num_copies_in_C} * max(2, ceil(log2(n))) <= {d_C_max_limit}")
    
    d_B_max_limit = d_C_max_limit // num_copies_in_C
    print(f"Divide by {num_copies_in_C}: max(2, ceil(log2(n))) <= {d_B_max_limit}")
    
    print("This implies that ceil(log2(n)) must be less than or equal to 2.")
    print("For ceil(log2(n)) <= 2, we must have log2(n) <= 2.")
    
    print("Solving for n: n <= 2^2")
    largest_n = 2**2
    print(f"So, the largest integer n is {largest_n}.")
    print("-" * 50)
    
    print("Final Verification:")
    print("For n = 4, the final equation is calculated as:")
    
    # Printing each number in the final equation for n=4
    log_val = math.log2(largest_n)
    ceil_log_val = math.ceil(log_val)
    d_B_n = max(d_A, ceil_log_val)
    d_C_n = num_copies_in_C * d_B_n

    print(f"d(C_4) = {num_copies_in_C} * max({d_A}, ceil(log2({largest_n})))")
    print(f"       = {num_copies_in_C} * max({d_A}, ceil({log_val:.2f}))")
    print(f"       = {num_copies_in_C} * max({d_A}, {ceil_log_val})")
    print(f"       = {num_copies_in_C} * {d_B_n}")
    print(f"       = {d_C_n}")
    print(f"This result ({d_C_n}) is indeed less than or equal to {d_C_max_limit}.")

solve_group_theory_problem()