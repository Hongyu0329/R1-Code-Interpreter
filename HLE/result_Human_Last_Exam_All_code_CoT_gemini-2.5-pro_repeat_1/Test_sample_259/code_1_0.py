import numpy as np
from collections import Counter
import math

def find_coordination_polyhedra():
    """
    Calculates and prints the coordination polyhedra for the ReAl12 crystal structure.
    
    The script performs the following steps:
    1. Parses hardcoded CIF data (lattice, atoms, symmetry).
    2. Generates all atoms in the unit cell by applying symmetry operations.
    3. Creates a supercell to ensure all potential neighbors are considered.
    4. For each unique atom, calculates distances to all other atoms.
    5. Identifies the first coordination shell by finding a significant gap in sorted distances.
    6. Counts the neighbors to determine the polyhedron's formula.
    7. Prints the results in the specified format.
    """
    
    # Step 1: Parse CIF data for ReAl12
    # Lattice parameters for the orthorhombic cell
    cell_lengths = np.array([7.6091, 6.6117, 9.0230])
    # The transformation matrix from fractional to Cartesian coordinates
    lattice_matrix = np.diag(cell_lengths)

    # Asymmetric (unique) atom sites
    asym_atoms = [
        {'label': 'Al_A', 'symbol': 'Al', 'frac': np.array([0.3182, 0.2158, 0.2500])},
        {'label': 'Al_B', 'symbol': 'Al', 'frac': np.array([0.0000, 0.3662, 0.1030])},
        {'label': 'Al_C', 'symbol': 'Al', 'frac': np.array([0.1743, 0.0000, 0.0000])},
        {'label': 'Re_A', 'symbol': 'Re', 'frac': np.array([0.0000, 0.0445, 0.2500])},
    ]

    # Symmetry operations for space group Cmcm (No. 63)
    sym_ops_str = [
        "-x+1/2,-y+1/2,-z", "-x+1/2,-y+1/2,z+1/2", "-x+1/2,y+1/2,-z+1/2",
        "-x+1/2,y+1/2,z", "-x,-y,-z", "-x,-y,z+1/2", "-x,y,-z+1/2", "-x,y,z",
        "x+1/2,-y+1/2,-z", "x+1/2,-y+1/2,z+1/2", "x+1/2,y+1/2,-z+1/2",
        "x+1/2,y+1/2,z", "x,-y,-z", "x,-y,z+1/2", "x,y,-z+1/2", "x,y,z"
    ]

    def apply_sym_op(op_str, frac_coords):
        """Applies a symmetry operation string to fractional coordinates."""
        x, y, z = frac_coords
        x_op, y_op, z_op = op_str.split(',')
        # eval is used for simplicity given the well-defined input format
        return np.array([eval(x_op), eval(y_op), eval(z_op)])

    # Step 2: Generate all atoms in the unit cell
    unit_cell_atoms = []
    seen_coords = []
    coord_tolerance = 1e-4

    for atom in asym_atoms:
        for op_str in sym_ops_str:
            new_frac = apply_sym_op(op_str, atom['frac'])
            new_frac -= np.floor(new_frac)  # Wrap coordinates into [0, 1)

            # Avoid adding duplicate atoms generated by symmetry
            is_duplicate = any(np.all(np.minimum(np.abs(new_frac - s), 1.0 - np.abs(new_frac - s)) < coord_tolerance) for s in seen_coords)
            
            if not is_duplicate:
                unit_cell_atoms.append({'symbol': atom['symbol'], 'frac': new_frac})
                seen_coords.append(new_frac)

    # Step 3: Create a 3x3x3 supercell for neighbor searching
    supercell_atoms = []
    for atom in unit_cell_atoms:
        for i in range(-1, 2):
            for j in range(-1, 2):
                for k in range(-1, 2):
                    translated_frac = atom['frac'] + np.array([i, j, k])
                    supercell_atoms.append({'symbol': atom['symbol'], 'frac': translated_frac})

    # Step 4, 5, 6: Find coordination environment for each unique atom
    results = []
    for central_atom in asym_atoms:
        center_cart = np.dot(lattice_matrix, central_atom['frac'])
        
        distances = []
        for neighbor in supercell_atoms:
            neighbor_cart = np.dot(lattice_matrix, neighbor['frac'])
            dist = np.linalg.norm(center_cart - neighbor_cart)
            
            if dist > coord_tolerance:
                distances.append({'dist': dist, 'symbol': neighbor['symbol']})

        distances.sort(key=lambda x: x['dist'])

        first_shell_neighbors = []
        if distances:
            first_shell_neighbors.append(distances[0])
            # Find the first shell by looking for a large gap (>25%) in distances
            for i in range(1, len(distances)):
                if distances[i]['dist'] < distances[i-1]['dist'] * 1.25:
                    first_shell_neighbors.append(distances[i])
                else:
                    break  # Gap found, shell is complete

        neighbor_counts = Counter(n['symbol'] for n in first_shell_neighbors)
        
        formula_parts = []
        # Sort elements alphabetically for a canonical formula
        for element in sorted(neighbor_counts.keys()):
            count = neighbor_counts[element]
            # The prompt requires outputting each number in the formula
            formula_parts.append(f"{element}{count if count > 1 else ''}")
        
        formula = "".join(formula_parts)
        results.append(f"{central_atom['symbol']}, {formula}")
        
    # Step 7: Print the final result
    print("; ".join(results))

find_coordination_polyhedra()