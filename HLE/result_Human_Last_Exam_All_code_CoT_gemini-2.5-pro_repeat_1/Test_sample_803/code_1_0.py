import sympy
from sympy.combinatorics.permutations import Permutation
from sympy.combinatorics.groups import PermutationGroup

def demonstrate_filled_property_for_D10():
    """
    This function demonstrates that D10 is a filled group by checking the condition
    for one of its maximal product-free sets.
    """
    # Based on the classification of filled soluble groups, the only nonabelian
    # filled group of order 2q^m is the dihedral group D_10.
    # For D_10, the order is 10 = 2 * 5^1.
    q = 5
    m = 1
    order = 2 * (q**m)
    
    print(f"Analyzing the candidate group: Dihedral group D_{order}")
    print("This group has order 10, which corresponds to the form 2*q^m for:")
    # As requested, printing the numbers in the final equation 10 = 2 * 5^1
    print(f"q = {q}")
    print(f"m = {m}")
    print("-" * 30)

    # 1. Create the Dihedral group D_10 (order 10) using SymPy
    # SymPy's DihedralGroup(5) creates the group of symmetries of a pentagon.
    D10 = sympy.combinatorics.DihedralGroup(5)
    print(f"Group: {D10.name}")
    print(f"Order: {D10.order()}")
    
    elements = list(D10.elements)
    identity = D10.identity
    
    # 2. Identify a maximal product-free set.
    # The set of all involutions (elements of order 2) in D_10 is a well-known
    # maximal product-free set.
    involutions = {g for g in elements if D10.element_order(g) == 2}
    
    print("\nConsidering the set S of all involutions (elements of order 2):")
    # To have a canonical representation, sort them by their string form
    sorted_involutions = sorted(list(involutions), key=str)
    print(f"S = {sorted_involutions}")

    # 3. Verify that S is product-free.
    # A set S is product-free if for all x, y in S, x*y is not in S.
    is_product_free = True
    for x in sorted_involutions:
        for y in sorted_involutions:
            product = x * y
            if product in involutions:
                print(f"Verification failed: S is not product-free because {x} * {y} = {product}, which is in S.")
                is_product_free = False
                break
        if not is_product_free:
            break
    
    if is_product_free:
        print("\nVerification successful: The set S is product-free.")

    # 4. Verify that S is maximal.
    # A product-free set S is maximal if for any element g not in S,
    # the set S U {g} is NOT product-free.
    is_maximal = True
    elements_not_in_S = [g for g in elements if g not in involutions]
    for g in elements_not_in_S:
        s_union_g = involutions.union({g})
        newly_product_free = True
        # Check if S U {g} is product-free
        for x in s_union_g:
            for y in s_union_g:
                if x*y in s_union_g:
                    newly_product_free = False
                    break
            if not newly_product_free:
                break
        if newly_product_free:
            print(f"Verification failed: S is not maximal because S U {{{g}}} is still product-free.")
            is_maximal = False
            break

    if is_maximal:
        print("Verification successful: The set S is a maximal product-free set.")

    # 5. Verify that S "fills" the group (i.e., generates the group).
    # A set S fills G if the subgroup generated by S is G itself.
    generated_subgroup = PermutationGroup(list(involutions))
    
    print("\nChecking if S fills the group (i.e., <S> = G):")
    print(f"Subgroup generated by S has order: {generated_subgroup.order()}")
    
    if generated_subgroup.order() == D10.order():
        print("Conclusion: The set S generates the entire group D_10.")
        print("\nThis demonstrates one instance of the 'filled' property for D_10.")
    else:
        print("Error: The set of involutions does not generate the group.")

if __name__ == '__main__':
    demonstrate_filled_property_for_D10()