import sympy

def solve_poynting_vector():
    """
    This function symbolically calculates the Poynting vector S for a moving charged 
    cylindrical rod in an external electric field, both inside and outside the rod.
    """
    # Define symbolic variables for the physical quantities
    # rho: volume charge density
    # R: radius of the rod
    # E: magnitude of the external electric field
    # v: speed of the rod
    # mu0: permeability of free space
    # epsilon0: permittivity of free space
    # r: radial distance from the axis of the rod
    rho, R, E, v, mu0, epsilon0, r = sympy.symbols('rho R E v mu_0 epsilon_0 r', real=True, positive=True)

    # We will compute the Poynting vector S = (1/mu0) * (E_total x B)
    # in cylindrical coordinates (r, phi, z), with the z-axis along the rod's axis.
    # The unit vectors are r_hat (radial), phi_hat (azimuthal), and k_hat (axial).

    # --- Calculation for inside the rod (r < R) ---
    
    # The total electric field E_total is the sum of the external field (E * k_hat)
    # and the field from the charge distribution within the rod.
    # Using Gauss's law for a cylinder of radius r < R:
    E_r_in = rho * r / (2 * epsilon0)
    E_z_in = E # The external field is E in the z-direction (k_hat).

    # The magnetic field B is generated by the moving charges, which form a current
    # density J = rho * v * k_hat.
    # Using Ampere's law for a loop of radius r < R:
    B_phi_in = mu0 * rho * v * r / 2 # The field is in the azimuthal direction (phi_hat).

    # The cross product E x B = (E_r_in * r_hat + E_z_in * k_hat) x (B_phi_in * phi_hat)
    # Using r_hat x phi_hat = k_hat and k_hat x phi_hat = -r_hat:
    # E x B = -E_z_in * B_phi_in * r_hat + E_r_in * B_phi_in * k_hat

    # The Poynting vector S = (1/mu0) * (E x B)
    S_r_in = (1 / mu0) * (-E_z_in * B_phi_in)
    S_z_in = (1 / mu0) * (E_r_in * B_phi_in)
    
    # Simplify the expressions
    S_r_in_simplified = sympy.simplify(S_r_in)
    S_z_in_simplified = sympy.simplify(S_z_in)

    # --- Calculation for outside the rod (r > R) ---

    # Electric field using Gauss's law for a cylinder of radius r > R:
    E_r_out = rho * R**2 / (2 * epsilon0 * r)
    E_z_out = E

    # Magnetic field using Ampere's law for a loop of radius r > R:
    B_phi_out = mu0 * rho * v * R**2 / (2 * r)

    # Poynting vector components S = (1/mu0) * (E x B)
    S_r_out = (1 / mu0) * (-E_z_out * B_phi_out)
    S_z_out = (1 / mu0) * (E_r_out * B_phi_out)

    # Simplify the expressions
    S_r_out_simplified = sympy.simplify(S_r_out)
    S_z_out_simplified = sympy.simplify(S_z_out)

    # --- Print the final results ---
    print("The Poynting vector S = S_r * r_hat + S_z * k_hat is computed for two regions.")
    
    print("\n--- Inside the rod (for a radial distance r < R) ---")
    print("The final equation for the Poynting vector is:")
    print(f"S(r < R) = ({S_r_in_simplified}) * r_hat + ({S_z_in_simplified}) * k_hat")
    print("The components of the vector are:")
    print(f"Radial component (S_r): {S_r_in_simplified}")
    print(f"Axial component (S_z): {S_z_in_simplified}")

    print("\n--- Outside the rod (for a radial distance r > R) ---")
    print("The final equation for the Poynting vector is:")
    print(f"S(r > R) = ({S_r_out_simplified}) * r_hat + ({S_z_out_simplified}) * k_hat")
    print("The components of the vector are:")
    print(f"Radial component (S_r): {S_r_out_simplified}")
    print(f"Axial component (S_z): {S_z_out_simplified}")
    
# Call the function to execute the calculation and print the results
solve_poynting_vector()