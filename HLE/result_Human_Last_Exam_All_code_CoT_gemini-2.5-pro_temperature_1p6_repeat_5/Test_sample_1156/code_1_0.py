import numpy as np

def find_invariant_density():
    """
    This function numerically calculates an approximate invariant density for the map
    T(x) = 1/sqrt(x) mod 1.

    The process is as follows:
    1. A large number of points are generated by iterating the map.
    2. A histogram of these points is computed to approximate the density.
    3. We assume the density has the form rho(x) = C * (1/sqrt(x) + B).
    4. A linear fit is performed on the histogram data to find the parameters B and C.
    5. The final normalized density rho(x) = (1/(2+B)) * (1/sqrt(x) + B) is constructed.
    """

    # 1. Simulation
    print("Starting simulation...")
    n_iter = 5_000_000
    n_transient = 1000
    x = np.random.rand()

    # Discard transient part of the trajectory
    for _ in range(n_transient):
        if x == 0:
            x = 0
        else:
            x = 1.0 / np.sqrt(x) % 1.0

    # Collect data points
    trajectory = np.empty(n_iter)
    for i in range(n_iter):
        if x == 0:
            x = 0
        else:
            x = 1.0 / np.sqrt(x) % 1.0
        trajectory[i] = x
    print("Simulation finished.")

    # 2. Histogram
    print("Computing histogram...")
    num_bins = 200
    # We use a sub-interval of [0, 1] to avoid issues with x=0
    # and to get a better fit where the density is not too high.
    fit_range = [0.01, 1.0]
    hist, bin_edges = np.histogram(
        trajectory, bins=num_bins, range=fit_range, density=True
    )
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.0

    # 3. Linear Fit
    print("Performing linear fit...")
    # The model is rho(x) ~= C * (1/sqrt(x) + B).
    # This is equivalent to y ~= C*z + C*B, where y=rho(x) and z=1/sqrt(x).
    # We can fit a line to the transformed data.
    z = 1.0 / np.sqrt(bin_centers)
    y = hist
    
    # Use numpy.polyfit to find the slope (m) and intercept (c) of the best-fit line.
    # The degree of the polynomial is 1 for a linear fit.
    m, c = np.polyfit(z, y, 1)

    # 4. Determine parameters
    # From the fit, we have:
    # m = C (the overall scaling factor)
    # c = C * B
    # So, B can be calculated as c / m.
    B = c / m
    
    # 5. Normalize and output the final function
    # The unnormalized density is rho_u(x) = 1/sqrt(x) + B.
    # The normalization constant is 1 / integral from 0 to 1 of rho_u(x) dx.
    # integral(1/sqrt(x) + B) dx = [2*sqrt(x) + B*x] from 0 to 1 = 2 + B.
    # So, the normalized density is rho(x) = (1/(2+B)) * (1/sqrt(x) + B).
    c1 = 1.0 / (2.0 + B)
    c2 = B / (2.0 + B)
    
    print("\n--- Results ---")
    print(f"The analysis suggests an approximate invariant density of the form:")
    print("rho(x) = c1/sqrt(x) + c2")
    print("\nCalculated coefficients:")
    print(f"c1 = {c1:.4f}")
    print(f"c2 = {c2:.4f}")

    print("\nFinal equation:")
    print(f"rho(x) = {c1:.4f} / sqrt(x) + {c2:.4f}")

    # Return one of the key parameters for the final answer block.
    # Parameter B is a good choice as it defines the shape of the density.
    return B

if __name__ == '__main__':
    B_val = find_invariant_density()
    # The problem asks for a single value in the final answer block.
    # The parameter 'B' determines the shape of the density function.
    # <<<B>>> is a placeholder for where the final answer value should go.
    # print(f"\n<<<B_val:{B_val:.4f}>>>")

# Execute the function
B_value = find_invariant_density()
print(f"\n<<<B={B_value:.4f}>>>")