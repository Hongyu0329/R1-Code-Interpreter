import itertools

def get_powerset(s):
    """Returns the powerset of a given set as a set of frozensets."""
    s_list = list(s)
    # Generate all combinations for each possible length from 0 to len(s)
    return set(
        frozenset(c) for i in range(len(s_list) + 1)
        for c in itertools.combinations(s_list, i)
    )

def solve():
    """
    Calculates and demonstrates the VC dimension for the given problem.
    The task is to find the VC dimension of the logic FO[exists, and, top, bot]
    over a schema with 4 unary predicates.
    """
    k = 4  # Number of unary predicates

    print(f"The schema S has {k} unary predicates, say P1, P2, P3, P4.")
    print("The logic fragment is FO[exists, and, top, bot, S].")
    print("\nStep 1: Simplify the problem.")
    print("For any model, a formula in this logic with one free variable 'x' is equivalent to a quantifier-free formula.")
    print("This is because predicates are unary, so parts like 'exists y. P_i(y)' are sentences (either True or False in a model).")
    print("The problem reduces to finding the VC dimension of concepts formed by monotone conjunctions of k predicates.")
    print("This is known to be k.")

    print(f"\nWe will prove that the VC dimension is {k}.")

    print("\nStep 2: Show VCDim <= 4.")
    print(f"There are {k} predicates, so we can form at most 2^{k} = {2**k} distinct concepts (by choosing which predicates to include in a conjunction).")
    print("To shatter a set of size d, we need 2^d distinct concepts.")
    print(f"Therefore, 2^d <= {2**k}, which implies d <= {k}.")

    print("\nStep 3: Show VCDim >= 4 by construction.")
    print("We must find a model and a set X of size 4 that can be shattered.")
    
    # Use strings for nice printing like 'x1', 'x2', etc.
    X = {f'x{i+1}' for i in range(k)}
    print(f"Let's take a set X = {sorted(list(X))}.")
    
    # Let the k predicates be P1, P2, ..., Pk. Their interpretations are sets S1, S2, ...
    predicate_names = {f'P{i+1}' for i in range(k)}
    element_map = {f'P{i+1}': f'x{i+1}' for i in range(k)}
    
    # We define the interpretation S_i for each predicate P_i as X \ {x_i}
    S = {p_name: X - {element_map[p_name]} for p_name in predicate_names}
    
    print("\nWe define a model by interpreting each predicate P_i as the set S_i = X \\ {x_i}:")
    for i in range(k):
        p_name = f'P{i+1}'
        print(f"S{i+1} = {sorted(list(S[p_name]))}")
        
    print("\nNow we verify that any subset Y of X can be generated by a concept C_I = intersection(S_i for P_i in I).")

    # Generate all subsets of X we need to form
    subsets_of_X_to_generate = get_powerset(X)
    generated_subsets = set()
    
    # The concepts are formed by taking all possible intersections of the predicate sets
    powerset_of_predicates = get_powerset(predicate_names)

    for I_frozenset in powerset_of_predicates:
        concept_formula = " AND ".join(sorted(list(I_frozenset))) if I_frozenset else "TRUE"
        
        # Calculate the resulting concept set
        current_concept_set = X.copy()
        for p_name in I_frozenset:
            current_concept_set.intersection_update(S[p_name])
        
        generated_subsets.add(frozenset(current_concept_set))

    if generated_subsets == subsets_of_X_to_generate:
        print(f"Success! All {len(subsets_of_X_to_generate)} subsets of X were generated. Thus, X is shattered.")
    else:
        print("Error: The construction failed to shatter X.")

    print("Since a set of size 4 can be shattered, the VC dimension is at least 4.")
    print("\nConclusion: As VCDim <= 4 and VCDim >= 4, the VC dimension is exactly 4.")
    
    # Printing the "final equation" and its numbers, as requested
    print("\n--- Example Equation ---")
    # To generate Y = {x1, x3}, its complement is {x2, x4}. So we intersect S2 and S4.
    Y = {'x1', 'x3'}
    I_indices_to_intersect = {2, 4}
    
    print(f"To generate the subset Y = {sorted(list(Y))}, we intersect S2 and S4:")
    equation_lhs = " \u2229 ".join([f'S{i}' for i in I_indices_to_intersect])
    
    s2_val = S['P2']
    s4_val = S['P4']
    result_set = s2_val.intersection(s4_val)
    equation_rhs = f"{{{', '.join(sorted(list(result_set)))}}}"
    
    print(f"Equation: {equation_lhs} = {equation_rhs}")
    
    # Print each number in the equation: 2, 4, 1, 3
    print("The numbers in this equation are: 2, 4, 1, 3")

solve()
<<<4>>>