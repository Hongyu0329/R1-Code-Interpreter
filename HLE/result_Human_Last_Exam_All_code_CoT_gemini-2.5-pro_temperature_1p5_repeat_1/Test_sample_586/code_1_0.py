import re

def analyze_sgrna_targets():
    """
    Analyzes potential sgRNA target sequences for the second exon of a given gene.
    """
    # Full gene sequence provided by the user
    full_sequence = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTCAGAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGGTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"

    # Split sequence into parts based on '^'
    parts = full_sequence.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]

    # Define the answer choices from the prompt
    options = {
        'A': 'AGCGGTTTACTGAGACCCGG(TGG)',
        'B': 'TCCGGCGGGTTTTCGAGTGGG',
        'C': 'TTCATGCCCCTGGATGCGCT(TGG)',
        'D': 'CAGGACCGGTTTCAGATGCG(CGG)',
        'E': 'GCATCTGAAACCGGTCCTG(TGG)',
        'F': 'GGAAGCAATCCTCCGAACGT(TGG)',
        'G': 'ACGTTGCGAGGACAGAGTCA(AGG)',
        'H': 'CCCTTTCACAAATCCTTCCT(TGG)',
        'I': 'TTCACCCGCACCTTGAACGG(AGG)',
        'J': 'CTTTCTTTCTTTCTTTCTTTC(TTT)',
        'K': 'CTGCTCTACCCAATCGCCA(TGG)',
        'L': 'TGCCTG(CGG)',
        'M': 'TGCAAAGTAGATCGAGATGG(AGG)',
        'N': 'ACAGTCCAGAAGGGCGATCA(AGG)',
        'O': 'ATG(ACC)'
    }

    # Function to parse the option string into target and PAM
    def parse_option(option_string):
        match = re.match(r'([A-Z]+)\((.+)\)', option_string)
        if match:
            return match.group(1), match.group(2)
        # For options without a PAM in parentheses
        return option_string, None

    print("--- sgRNA Target Analysis ---\n")
    print("Target Region: Exon 2\n")

    best_option_key = None
    final_equation_output = ""

    for key, value in options.items():
        print(f"--- Analyzing Option {key}: {value} ---")
        target_seq, pam_seq = parse_option(value)

        # Step 1: Check for basic structural validity
        if len(target_seq) < 17:
            print("Result: UNSUITABLE. Reason: Target sequence is too short.\n")
            continue
        if pam_seq is None:
            print("Result: UNSUITABLE. Reason: No PAM sequence was specified.\n")
            continue
        if not (len(pam_seq) == 3 and pam_seq.endswith('GG')):
            print(f"Result: UNSUITABLE. Reason: PAM '{pam_seq}' is not a valid NGG motif for spCas9.\n")
            continue

        # Step 2: Check if the target is in the correct location (Exon 2)
        search_string = target_seq + pam_seq
        
        exon2_match_index = exon2.find(search_string)
        if exon2_match_index != -1:
            print(f"Result: FOUND in Exon 2 at index {exon2_match_index}.")
            print("Conclusion: SUITABLE target.\n")
            best_option_key = key
            
            # Formatting the final equation-like output for the selected answer
            context_before = exon2[exon2_match_index-10:exon2_match_index]
            context_after = exon2[exon2_match_index+len(search_string):exon2_match_index+len(search_string)+10]
            equation_str = (f"Location in DNA: ...{context_before}|{target_seq}|{pam_seq}|{context_after}...\n"
                            f"Target Equation: {target_seq} + {pam_seq}")
            final_equation_output = equation_str
        
        elif exon1.find(search_string) != -1:
            print("Result: FOUND in Exon 1.")
            print("Conclusion: UNSUITABLE. Reason: Targets the wrong exon.\n")
        elif intron.find(search_string) != -1:
            print("Result: FOUND in Intron.")
            print("Conclusion: UNSUITABLE. Reason: Targets an intron, which is non-coding and spliced out.\n")
        else:
            print("Result: NOT FOUND in the target region (Exon 2).")
            # Add a specific note for option 'E', which is a very close but incorrect match
            if key == 'E':
                print("Note: A similar sequence 'CGCATCTGAAACCGGTCCTGTGG' exists, but it does not exactly match the option's 'GCAT...' start.")
            print("Conclusion: UNSUITABLE.\n")
            
    print("--- Final Verdict ---")
    if best_option_key:
        print(f"Based on the analysis, Option {best_option_key} is the only choice that represents a suitable sgRNA target.")
        print("It is located correctly within Exon 2 and is followed by a valid spCas9 PAM (TGG).")
        print("\nFinal Target Breakdown:")
        print(final_equation_output)
    else:
        print("No suitable option was found in the list.")

if __name__ == '__main__':
    analyze_sgrna_targets()
<<<K>>>