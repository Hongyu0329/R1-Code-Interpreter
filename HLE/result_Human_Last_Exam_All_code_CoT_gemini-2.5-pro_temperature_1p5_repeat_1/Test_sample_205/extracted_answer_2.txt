171[void main() {
    // This program calculates 100! using an array to handle the large number.
    // Total memory for variables: 158D (array) + 3D (num_digits) + 2D (i) + 2D (j) + 2D (carry) + 3D (product) = 170D.

    // Array to hold the digits of the result. 100! has exactly 158 digits.
    digit result[158];
    // Number of digits currently in the result. Max is 158, so char (0-999) is the smallest suitable type.
    char num_digits;
    // Loop counter for factorial (i=2..100) and for iterating digits (j).
    // A short (0-99) is efficient for 'i'. 'j' needs to go up to 157. 'short' is too small, let's use a char instead
    // Correction from plan: 'j' must be able to reach 157. short (max 99) is too small. 'char' (max 999) is required.
    // Recalculating memory: 158(result) + 3(num_digits) + 2(i) + 3(j) + 2(carry) + 3(product) = 171D. Let's optimize.
    // If 'j' is declared inside the loops' scope (if the compiler supports it), we could save memory.
    // Assuming the compiler follows basic C rules where variables are function-scoped, we declare them at the top.
    // To minimize memory, let's reuse 'i' as the inner loop counter after its main use is done.
    // Let's stick to the clear version: using 'i' and 'j'. 'short j' (max 99) is indeed too small. It must be 'char j'.
    // Final memory recalculation: 158(result) + 3(num_digits) + 2(i) + 3(j) + 2(carry) + 3(product) = 171D. Let's proceed with 171.
    short i;
    char j;
    // Carry for multiplication. Max carry will be (9*100+99)/10=99. short (0-99) is perfect.
    short carry;
    // Product of a digit and i. Max will be 9*100+99=999. char (0-999) is perfect.
    char product;

    // Initialize result array to all zeros.
    for (j = 0; j < 158; j = j + 1) {
        result[j] = 0;
    }

    // Start with 1! = 1. The number is stored in reverse order (least significant digit first).
    result[0] = 1;
    num_digits = 1;

    // Calculate factorial by multiplying numbers from 2 to 100.
    for (i = 2; i <= 100; i = i + 1) {
        carry = 0;
        // Multiply the current number in 'result' by 'i'.
        for (j = 0; j < num_digits; j = j + 1) {
            product = result[j] * i + carry;
            result[j] = product % 10;
            carry = product / 10;
        }

        // If a carry remains, extend the number of digits.
        while (carry > 0) {
            result[num_digits] = carry % 10;
            carry = carry / 10;
            num_digits = num_digits + 1;
        }
    }

    // Print the final result. The digits are stored in reverse, so we print backwards.
    // This loop fulfills the requirement to "output each number in the final equation!".
    printf("100! = ");
    for (j = num_digits - 1; j >= 0; j = j - 1) {
        printf("%d", result[j]);
    }
    printf("\\n");
}
]