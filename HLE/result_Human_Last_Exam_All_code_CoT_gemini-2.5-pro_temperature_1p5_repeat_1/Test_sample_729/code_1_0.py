import math

def count_divisors(n):
    """
    Calculates the number of divisors of n (tau function).
    This helper function is used to find the number of subgroups
    in a cyclic group.
    """
    if n <= 0:
        return 0
    count = 0
    # A number n always has a divisor 1 and n.
    # We can find other divisors by checking up to sqrt(n).
    limit = int(math.sqrt(n))
    for i in range(1, limit + 1):
        if n % i == 0:
            # If i is a divisor, n/i is also a divisor.
            if n / i == i:
                # Perfect square, count i only once.
                count += 1
            else:
                # Otherwise, count both i and n/i.
                count += 2
    return count

def solve_quaternion_subgroups():
    """
    Calculates the number of power subgroups (cyclic subgroups)
    in the generalized quaternion group of size 128.
    """
    # Step 1: Define group parameters based on the problem statement.
    group_order = 128
    # For Q_{4n}, n = group_order / 4
    n_param = group_order // 4
    # The maximal cyclic subgroup <x> has order 2n.
    x_order = 2 * n_param

    print("This script calculates the number of power subgroups (cyclic subgroups) in the generalized quaternion group Q_128.")
    print("The group Q_128 is of order 128 and has a maximal cyclic subgroup <x> of order 64.")
    print("-" * 50)

    # Step 2: Calculate the number of cyclic subgroups contained within <x>.
    # <x> is a cyclic group of order 64. The number of its subgroups is tau(64).
    num_subgroups_in_x = count_divisors(x_order)
    print(f"Part 1: Counting cyclic subgroups within the maximal cyclic subgroup <x>.")
    print(f"The subgroup <x> is cyclic of order {x_order}.")
    print(f"The number of subgroups of a cyclic group of order k is tau(k) (the number of divisors of k).")
    print(f"The number of these subgroups is tau({x_order}) = {num_subgroups_in_x}.")
    print("-" * 50)

    # Step 3: Calculate the number of cyclic subgroups not contained within <x>.
    # These are generated by elements of the form yx^i.
    num_other_elements = x_order
    # The order of any element yx^i is 4.
    element_order = 4
    # The number of generators of a cyclic group of order 4 is phi(4) = 2.
    generators_per_group = 2  # phi(4)
    # The number of distinct subgroups is the number of elements divided by the number of generators per group.
    num_other_subgroups = num_other_elements // generators_per_group

    print(f"Part 2: Counting cyclic subgroups not contained in <x>.")
    print(f"These are generated by the {num_other_elements} elements of the form yx^i.")
    print(f"All these elements have order {element_order}.")
    print(f"Each cyclic group of order {element_order} has phi({element_order}) = {generators_per_group} generators.")
    print(f"So, these {num_other_elements} elements generate {num_other_elements} / {generators_per_group} = {num_other_subgroups} distinct subgroups.")
    print("-" * 50)

    # Step 4: Sum the two counts to get the total.
    total_subgroups = num_subgroups_in_x + num_other_subgroups
    
    print("Final Result:")
    print("The total number of power subgroups is the sum of the counts from Part 1 and Part 2.")
    print(f"Total number of power subgroups = (subgroups in <x>) + (subgroups not in <x>)")
    print(f"Total = {num_subgroups_in_x} + {num_other_subgroups} = {total_subgroups}")

solve_quaternion_subgroups()