import itertools

def closure_under_op(sets, op, X_set):
    """
    Computes the closure of a collection of sets under a binary set operation.
    
    Args:
        sets (set of frozensets): The initial collection of sets.
        op (function): The binary operation (e.g., frozenset.union).
        X_set (frozenset): The universal set. Not strictly needed for union/intersection
                         but good practice for context.
    
    Returns:
        set of frozensets: The closed collection of sets.
    """
    closure = set(sets)
    if op == frozenset.union:
        # The empty union is the empty set
        closure.add(frozenset())
    elif op == frozenset.intersection:
        # The empty intersection is the universal set
        closure.add(X_set)
        
    newly_added = list(closure)
    
    while newly_added:
        s1 = newly_added.pop()
        # Combine the new set with all existing sets in the closure
        current_closure = list(closure)
        for s2 in current_closure:
            result = op(s1, s2)
            if result not in closure:
                closure.add(result)
                newly_added.append(result)
    return closure

def get_dual_topology(T, X_set):
    """
    Computes the dual of a topology on a finite set.

    Args:
        T (frozenset): The original topology (a frozenset of frozensets).
        X_set (frozenset): The universal set.

    Returns:
        frozenset: The dual topology.
    """
    # On a finite space, all subsets are compact.
    # So the closed sub-basis for the dual topology is the set of all saturated sets.

    # 1. Find S, the saturated sets of T. This is the closure of T under intersection.
    # A set is saturated if it is an intersection of open sets from T.
    S_saturated_sets = closure_under_op(T, frozenset.intersection, X_set)

    # 2. Generate the closed sets of the dual topology.
    # The closed sub-basis is S.
    # The closed sets are arbitrary intersections of finite unions of sets in S.
    # For a finite space, this simplifies.
    
    # 2a. First, find the basis for the closed sets: finite unions of sets from S.
    B_closed_basis = closure_under_op(S_saturated_sets, frozenset.union, X_set)
    
    # 2b. Then, find all closed sets: intersections of sets from the basis.
    C_dual_closed_sets = closure_under_op(B_closed_basis, frozenset.intersection, X_set)

    # 3. The dual topology T* is the set of complements of the closed sets.
    T_dual = {X_set - s for s in C_dual_closed_sets}
    
    return frozenset(T_dual)

def main():
    """
    Main function to execute the calculation.
    """
    # The 4-point set {a, b, c, d} is represented by {0, 1, 2, 3}
    X_set = frozenset({0, 1, 2, 3})

    # This is the topology T_0 from Kong, Kopperman, and Meyer (1991)
    # which gives the maximal sequence.
    # It's generated by the basis of minimal open neighborhoods:
    # N(a)={a,c}, N(b)={a,b}, N(c)={c}, N(d)={a,b,d}
    # where a=0, b=1, c=2, d=3.
    basis = {
        frozenset({0, 2}),  # {a,c}
        frozenset({0, 1}),  # {a,b}
        frozenset({2}),     # {c}
        frozenset({0, 1, 3}) # {a,b,d}
    }
    
    # Generate the full topology T_0 from the basis by taking all possible unions
    T0 = closure_under_op(basis, frozenset.union, X_set)
    
    # List to store the sequence of distinct topologies found
    topologies = []
    # Dictionary to quickly check if a topology has been seen before
    seen_topologies = {}

    current_T = frozenset(T0)
    
    iteration = 0
    while current_T not in seen_topologies:
        topologies.append(current_T)
        seen_topologies[current_T] = iteration
        
        print(f"Found T_{iteration} with {len(current_T)} open sets.")

        current_T = get_dual_topology(current_T, X_set)
        iteration += 1

    cycle_start_index = seen_topologies[current_T]
    print(f"\nCycle detected at iteration {iteration}.")
    print(f"T_{iteration} is the same as T_{cycle_start_index}.")

    num_distinct_topologies = len(topologies)
    print("\nThe sequence of distinct topologies is:", ", ".join([f"T_{i}" for i in range(num_distinct_topologies)]))
    print("\n---------------------------------------------------------------------")
    print(f"The largest possible number of distinct topologies is: {num_distinct_topologies}")
    print("---------------------------------------------------------------------")


if __name__ == "__main__":
    main()
<<<10>>>