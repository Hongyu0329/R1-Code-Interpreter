import re

def find_best_sgrna():
    """
    Analyzes a list of potential sgRNA sequences to find the most suitable one
    for targeting the second exon of a given gene with spCas9.
    """
    # The full DNA sequence provided by the user
    full_sequence = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTTCAAGGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGTTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"

    # Split the sequence into exons and intron
    parts = full_sequence.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]

    # Answer choices provided by the user
    choices = {
        'A': 'AGCGGTTTACTGAGACCCGG(TGG)', 'B': 'TCCGGCGGGTTTTCGAGTGGG',
        'C': 'TTCATGCCCCTGGATGCGCT(TGG)', 'D': 'CAGGACCGGTTTCAGATGCG(CGG)',
        'E': 'GCATCTGAAACCGGTCCTG(TGG)', 'F': 'GGAAGCAATCCTCCGAACGT(TGG)',
        'G': 'ACGTTGCGAGGACAGAGTCA(AGG)', 'H': 'CCCTTTCACAAATCCTTCCT(TGG)',
        'I': 'TTCACCCGCACCTTGAACGG(AGG)', 'J': 'CTTTCTTTCTTTCTTTCTTTC(TTT)',
        'K': 'CTGCTCTACCCAATCGCCA(TGG)', 'L': 'TGCCTG(CGG)',
        'M': 'TGCAAAGTAGATCGAGATGG(AGG)', 'N': 'ACAGTCCAGAAGGGCGATCA(AGG)',
        'O': 'ATG(ACC)'
    }

    print("--- Analysis of sgRNA Candidates ---")
    valid_candidates = {}

    for key, value in choices.items():
        # Parse the target and PAM from the string
        match = re.match(r'([ATGC]+)\(([ATGC]{3})\)', value)
        target_seq, pam_seq = (match.group(1), match.group(2)) if match else (None, None)

        # Handle malformed entries without parentheses
        if not target_seq:
            print(f"Choice {key}: {value:<30} -> Status: Invalid format")
            continue

        # Check for valid NGG PAM
        if not (pam_seq[1] == 'G' and pam_seq[2] == 'G'):
            print(f"Choice {key}: {value:<30} -> Status: Invalid PAM ('{pam_seq}')")
            continue

        full_site = target_seq + pam_seq
        position = exon2.find(full_site)

        # Check if the site is in the second exon
        if position != -1:
            gc_count = target_seq.count('G') + target_seq.count('C')
            gc_percent = (gc_count / len(target_seq)) * 100
            print(f"Choice {key}: {value:<30} -> Status: Valid. Found at pos {position}. GC: {gc_percent:.1f}%")
            valid_candidates[key] = position
        elif exon1.find(full_site) != -1:
            print(f"Choice {key}: {value:<30} -> Status: Invalid location (First Exon)")
        elif intron.find(full_site) != -1:
            print(f"Choice {key}: {value:<30} -> Status: Invalid location (Intron)")
        else:
            print(f"Choice {key}: {value:<30} -> Status: Not found in sequence")

    print("\n--- Conclusion ---")
    if not valid_candidates:
        print("No suitable sgRNA candidate was found in the second exon.")
        return

    # Find the best candidate (the one that appears earliest in the exon)
    best_choice = min(valid_candidates, key=valid_candidates.get)
    
    print(f"Valid candidates found in the second exon: {', '.join(valid_candidates.keys())}.")
    print("To maximize the chance of creating a loss-of-function mutation, targeting earlier in the exon is preferred.")
    print(f"Candidate E (pos {valid_candidates['E']}) is located much earlier than Candidate K (pos {valid_candidates['K']}).")
    print(f"\nTherefore, the most suitable target sequence is E.")
    
    print(f"<<<{best_choice}>>>")

if __name__ == '__main__':
    find_best_sgrna()