import math

def count_divisors_power_of_2(num):
    """
    Calculates the number of divisors for a number that is a power of 2.
    For a number num = 2^k, the number of divisors is k+1.
    """
    if num <= 0 or (num & (num - 1)) != 0:
        # This check ensures the number is a power of 2.
        # It's not strictly necessary for this problem but is good practice.
        return 0
    exponent = int(math.log2(num))
    return exponent + 1

# Define group parameters for Q_128
group_order = 128
n = int(math.log2(group_order)) # n=7

# The order of the maximal cyclic subgroup <x> is 2^(n-1)
max_cyclic_subgroup_order = 2**(n - 1)

# The number of cyclic subgroups within <x> is the number of divisors of its order.
# For order 64 = 2^6, there are 6+1=7 divisors.
subgroups_in_cyclic_part = count_divisors_power_of_2(max_cyclic_subgroup_order)

# The number of elements outside the maximal cyclic subgroup is group_order - max_cyclic_subgroup_order
num_other_elements = group_order - max_cyclic_subgroup_order

# These elements (of the form x^i*y) all have order 4.
# A cyclic subgroup of order 4 has phi(4)=2 generators.
# The generators of <x^i*y> are x^i*y and (x^i*y)^3. Both are of the same form.
# Thus, the number of distinct subgroups is the number of elements divided by 2.
other_subgroups_count = num_other_elements // 2

# Total number of power subgroups is the sum of the two counts.
total_power_subgroups = subgroups_in_cyclic_part + other_subgroups_count

print(f"The number of power (cyclic) subgroups in the maximal cyclic subgroup of order {max_cyclic_subgroup_order} is {subgroups_in_cyclic_part}.")
print(f"The number of power (cyclic) subgroups generated by the other {num_other_elements} elements is {other_subgroups_count}.")
print("\nThe total number of power subgroups is:")
print(f"{subgroups_in_cyclic_part} + {other_subgroups_count} = {total_power_subgroups}")