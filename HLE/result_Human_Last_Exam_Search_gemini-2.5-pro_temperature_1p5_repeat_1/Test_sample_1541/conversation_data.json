{
  "question": "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>.",
  "response_list": [
    "To solve this problem with the highest memory efficiency, we should avoid storing the entire input string in memory. Since the numbers are limited to 1, 2, 3, and 4, we can use a counting sort approach. We can read the input character by character, and for each number we encounter, we increment a counter for that number. After counting all the numbers, we can then print the sorted sum by first printing all the 1s, then all the 2s, and so on, separated by plus signs.\n\nThis approach avoids allocating a large character array (up to 1001 bytes) for the input string or an integer array for the numbers (up to 501 integers).\n\nHere is the most memory-efficient C program for this task:\n\n```c\n#include <stdio.h>\n\n/**\n * This program solves the Xenia and Sum problem with maximum memory efficiency.\n * It reads the sum character by character, avoiding storing the whole string.\n * It uses an array 'counts' to store the frequency of each number (1, 2, 3, 4).\n * This is a form of counting sort.\n * After counting, it constructs and prints the sorted sum.\n */\nint main() {\n    // Array to store the frequency of numbers 1, 2, 3, and 4.\n    // counts[0] for '1', counts[1] for '2', etc.\n    int counts[4] = {0};\n    \n    // Variable to hold the character being read from input.\n    char ch;\n\n    // Read input character by character until a newline or end-of-file is found.\n    while ((ch = getchar()) != '\\n' && ch != EOF) {\n        // If the character is a digit (and not '+'), increment the corresponding counter.\n        if (ch >= '1' && ch <= '4') {\n            counts[ch - '1']++;\n        }\n    }\n\n    // A flag to correctly place the '+' signs between numbers.\n    int is_first_term = 1;\n    \n    // Loop through the numbers 1 to 4.\n    for (int i = 0; i < 4; i++) {\n        // Loop 'counts[i]' times to print each occurrence of the number (i+1).\n        for (int j = 0; j < counts[i]; j++) {\n            // If it's not the very first number being printed, print a '+' first.\n            if (!is_first_term) {\n                putchar('+');\n            }\n            // Print the number character.\n            putchar(i + '1');\n            // Update the flag.\n            is_first_term = 0;\n        }\n    }\n    putchar('\\n');\n\n    return 0;\n}\n```\n\n### Memory Usage Calculation (m)\n\nThe total memory `m` is the sum of the memory used by all variables declared in the program. We assume a standard environment where `sizeof(int)` is 4 bytes and `sizeof(char)` is 1 byte.\n\n*   `int counts[4]`: An array of 4 integers. Memory = 4 * `sizeof(int)` = 4 * 4 = 16 bytes.\n*   `char ch`: A single character. Memory = 1 * `sizeof(char)` = 1 * 1 = 1 byte.\n*   `int is_first_term`: A single integer flag. Memory = 1 * `sizeof(int)` = 1 * 4 = 4 bytes.\n*   `int i`: Loop counter variable. Memory = 1 * `sizeof(int)` = 1 * 4 = 4 bytes.\n*   `int j`: Nested loop counter variable. Memory = 1 * `sizeof(int)` = 1 * 4 = 4 bytes.\n\nTotal memory (m) = 16 + 1 + 4 + 4 + 4 = **29 bytes**.\n\n<<<29>>>"
  ],
  "user_prompt_list": [
    "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>."
  ],
  "system_message": ""
}