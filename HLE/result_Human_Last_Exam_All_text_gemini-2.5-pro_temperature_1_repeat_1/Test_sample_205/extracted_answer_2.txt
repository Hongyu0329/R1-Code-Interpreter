172[
// Program to calculate 100! for the Wuxing computer.
// It is optimized to use the minimum amount of memory for variables.

void main() {
    // --- Variable Declarations and Memory Analysis ---
    // Total memory is the sum of the sizes of all local variables.

    // result: Stores the 158 digits of 100!.
    // Type: digit (1D). Size: 158 * 1D = 158D.
    digit result[158];

    // i: Factorial multiplier, loops from 2 to 100.
    // Type: char (3D, 0-999) is the smallest type that holds 100.
    // Size: 3D.
    char i;

    // j: Index for the digit array, loops up to 157.
    // Type: char (3D, 0-999) is the smallest type that holds 157.
    // Size: 3D.
    char j;

    // num_digits: Tracks the number of active digits in the result. Max 158.
    // Type: char (3D, 0-999) is the smallest type that holds 158.
    // Size: 3D.
    char num_digits;

    // carry: Carry-over for multiplication. Max value is 99.
    // Type: short (2D, 0-99) is sufficient and minimal.
    // Size: 2D.
    short carry;

    // product: Temporary storage for multiplication result before splitting.
    // Max value: result[j]*i + carry <= 9*100+99 = 999.
    // Type: char (3D, 0-999) is sufficient and minimal.
    // Size: 3D.
    char product;

    // --- Total Memory for Variables ---
    // 158(result) + 3(i) + 3(j) + 3(num_digits) + 3(product) + 2(carry) = 172D

    // Initialization: Set result to 1 and clear the rest of the array.
    result[0] = 1;
    for (j = 1; j < 158; j++) {
        result[j] = 0;
    }
    num_digits = 1;

    // Main Calculation Loop: Compute 100!
    for (i = 2; i <= 100; i++) {
        carry = 0;
        // Multiply each digit of the current result by i
        for (j = 0; j < num_digits; j++) {
            product = result[j] * i + carry;
            result[j] = product % 10;
            carry = product / 10;
        }

        // Propagate remaining carry, extending the number's length if needed
        while (carry > 0) {
            result[num_digits] = carry % 10;
            carry = carry / 10;
            num_digits++;
        }
    }

    // Output: Print the final result.
    // Digits are stored in reverse order, so we iterate backwards.
    // A while loop is used to safely handle the possibly unsigned index 'j'.
    printf("100! = ");
    j = num_digits;
    while (j > 0) {
        j--;
        printf("%d", result[j]);
    }
    printf("\n");
}
]