The final answer is a detailed design based on the FROST protocol.
1.  **Foundation:** Choose the Schnorr signature scheme for its linear properties.
2.  **Key Generation:** Use a `t-out-of-n` Pedersen Distributed Key Generation (DKG) protocol. This provides each of the `n` parties with a secret share `xᵢ` and a corresponding public verification key `Pᵢ=xᵢG`, and establishes a single group public key `P`.
3.  **Signing Protocol (Two Rounds):**
    *   **Round 1 (Commitment):** Each of the `t` participating signers `i` generates two secret nonces `(dᵢ, eᵢ)`, computes the commitments `Dᵢ=dᵢG` and `Eᵢ=eᵢG`, and broadcasts `(Dᵢ, Eᵢ)`.
    *   **Round 2 (Signing):** After receiving all commitments, each signer `i` performs the following:
        a. Computes a binding factor `ρⱼ = H(j, m, {D_k, E_k})` for each participant `j`, which cryptographically binds each participant's contribution to the unique session context (message `m`, and the set of all commitments).
        b. Computes the group nonce commitment `R = Σ(Dⱼ + ρⱼEⱼ)`.
        c. Computes the group challenge `c = H(R, P, m)`.
        d. Computes their partial signature `sᵢ = dᵢ + (eᵢ * ρᵢ) + (c * λᵢ * xᵢ)`, where `λᵢ` is their Lagrange coefficient.
        e. Broadcasts `sᵢ`.
4.  **Aggregation:** A designated aggregator verifies each incoming partial signature `sᵢ` using public values `Pᵢ` before summing them to create the final signature `s = Σsᵢ`. The final, verifiable signature is the pair `(R, s)`. This design is tightly secure because the binding factor prevents cross-session attacks that plague simpler threshold Schnorr schemes.