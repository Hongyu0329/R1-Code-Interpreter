def find_rotation_index(A, B):
    """
    Finds the rotation index i such that B = A[i:] + A[:i].

    This function uses an optimal O(n) algorithm. It first finds the
    index 'i' of the first element of B within A. This 'i' is the only
    possible candidate for the rotation index. Then, it verifies if
    rotating A by 'i' indeed results in B.

    Args:
        A (list): A list of n unique integers.
        B (list): A list which is a cyclic shift of A.
    """
    n = len(A)
    m = len(B)

    if n != m:
        print("Error: Lists must have the same length.")
        return

    if n == 0:
        print("The rotation index is i = 0.")
        print("B = A[0:] + A[:0]")
        print("[] = [] + []")
        return

    # The problem guarantees B is a rotation of A.
    # The first element of B must exist in A.
    # We find its index 'i', which is our candidate for the rotation.
    # This step has a time complexity of O(n).
    try:
        first_b_element = B[0]
        i = A.index(first_b_element)
    except ValueError:
        # This case shouldn't be reached given the problem constraints.
        print(f"Error: Element {first_b_element} not found in A.")
        return

    # To be certain, we must verify our candidate 'i'.
    # We check if the list generated by rotating A by 'i' is identical to B.
    # This verification step has a time complexity of O(n).
    # Thus, the total complexity is O(n) + O(n) = O(n).
    if A[i:] + A[:i] == B:
        print(f"The rotation index is i = {i}.")
        print("The equation is B = A[i:] + A[:i]")
        # Output each number in the final equation
        print(f"{B} = {A[i:]} + {A[:i]}")
    else:
        # This case shouldn't be reached given the problem constraints.
        print("Error: B is not a cyclic shift of A.")


# Example Usage:
A = [10, 20, 30, 40, 50]
# Rotate A by i=3 to get B
# A[3:] = [40, 50]
# A[:3] = [10, 20, 30]
# B = [40, 50, 10, 20, 30]
B = [40, 50, 10, 20, 30]

find_rotation_index(A, B)