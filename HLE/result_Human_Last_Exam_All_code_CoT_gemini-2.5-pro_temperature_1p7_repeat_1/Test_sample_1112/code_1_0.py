def solve():
    """
    This program calculates the next 10 characters of a sequence generated by a specific
    87-byte Python program (related to OEIS A229046).

    The generation rule is based on a state variable `p`, which is updated at each step.
    This implementation first brings the state `p` to where it would be after generating
    the given prefix, and then computes the next 10 characters.

    Warning: This script is computationally intensive due to operations on very large numbers
    and may take several minutes to complete.
    """
    
    # The magic constant from the original program (9**7)
    C = 4782969
    
    # The length of the provided prefix.
    prefix_len = 5000
    
    # Initial state of the generator
    p = 1
    
    # We first advance the state of the generator `p` by `prefix_len` steps.
    # This loop simulates the generation of the prefix to get `p` to the correct state.
    for i in range(prefix_len):
        p_old = p
        
        # In Python, bitwise operators on negative numbers are handled as if
        # the numbers were in two's complement with an infinite number of bits.
        # The `p_old << p_old` operation creates extremely large numbers.
        
        # The update rule for p:
        p = ((p_old << p_old) & (p_old - 2)) | (p_old % 2 * C)

    # Now that p is at the correct state, we generate the next 10 characters.
    result_chars = []
    for _ in range(10):
        p_old = p
        
        # The next bit is '1' if p is odd, and '0' if p is even.
        bit = p_old % 2
        result_chars.append(str(bit))
        
        # Update p for the next iteration
        p = ((p_old << p_old) & (p_old - 2)) | (p_old % 2 * C)
        
    # Join the characters and print the result
    print("".join(result_chars))

solve()