import numpy as np

def demonstrate_vector_beam_limitation():
    """
    This function explains and demonstrates why an arbitrary vector beam cannot be
    generated from a single linearly polarized input beam.

    The core idea is that we are trying to control two independent functions
    at the output (the two polarization components of the vector beam) using
    only one function at the input (the scalar input beam). This is fundamentally
    not possible for an *arbitrary* output.
    """

    print("--- Conceptual Explanation ---")
    print("An input beam with fixed linear polarization is a SCALAR beam.")
    print("It can be described by a single complex function: A_in(x, y).")
    print("An arbitrary VECTOR beam requires TWO independent complex functions:")
    print("E_x_out(x, y) and E_y_out(x, y).")
    print("\nThe optical system described is a fixed linear system. It maps the single input")
    print("to two outputs, but these outputs are linked, not independent:")
    print("E_x_out = System_X(A_in)")
    print("E_y_out = System_Y(A_in)")
    print("Since both E_x_out and E_y_out depend on the same A_in, their relationship")
    print("is fixed. We cannot choose them arbitrarily.")

    # --- Numerical Demonstration ---
    print("\n--- Numerical Demonstration ---")

    # 1. Define a grid and a 'tailored' scalar input beam
    grid_size = 20
    x = np.linspace(-1, 1, grid_size)
    xx, yy = np.meshgrid(x, x)
    # Our input is a scalar field (e.g., a Laguerre-Gaussian-like mode)
    input_amplitude = np.exp(-(xx**2 + yy**2) / 0.5**2)
    input_phase = np.exp(1j * 2 * np.arctan2(yy, xx))
    A_input = input_amplitude * input_phase

    # 2. Model the 'random medium' and propagation as two fixed transfer functions
    # This represents the fixed physical properties of the system.
    np.random.seed(42)
    # T_x defines how A_in is transformed into the output x-component
    T_x = np.random.rand(grid_size, grid_size) + 1j * np.random.rand(grid_size, grid_size)
    # T_y defines how A_in is transformed into the output y-component
    T_y = np.random.rand(grid_size, grid_size) + 1j * np.random.rand(grid_size, grid_size)

    # 3. Define an ARBITRARY target vector beam we want to create
    # Let's choose a radially polarized beam as our target.
    # The amplitude can be anything; we'll use the input beam's amplitude.
    phi = np.arctan2(yy, xx)
    Ex_target = input_amplitude * np.cos(phi)
    Ey_target = input_amplitude * np.sin(phi)
    print("\nOur goal is to create a radially polarized beam where, for each point (x,y),")
    print("the polarization is (cos(phi), sin(phi)).")


    # 4. The "Wavefront Shaping" Approach: Can we find an A_input that works?
    print("\nLet's try to find an A_input that would produce this target beam.")
    print("To produce the target X-component, we would need to solve E_x_target = T_x * A_input.")
    # This gives us the required input field:
    required_A_input = Ex_target / T_x

    print("We have now calculated the specific input beam 'A_input' required to get the correct")
    print("X-component (Ex_target) of our desired vector beam.")

    # Now, let's see what Y-component this calculated input *actually* produces
    # when passed through the system's Y-transformation, T_y.
    generated_Ey = T_y * required_A_input

    # 5. Check if the generated Y-component matches the desired Y-component
    print("\nNow, the crucial check: Does this A_input ALSO produce the correct Y-component (Ey_target)?")
    
    # Pick a single point on the grid to show the numbers
    idx = (grid_size // 4, grid_size // 2)
    gen_ey_val = generated_Ey[idx]
    target_ey_val = Ey_target[idx]
    
    print(f"Let's check the numbers for a single point in the beam:")
    print(f"The Y-component generated by our tailored input is: {gen_ey_val.real:.4f} + {gen_ey_val.imag:.4f}j")
    print(f"The Y-component we actually wanted was:          {target_ey_val.real:.4f} + {target_ey_val.imag:.4f}j")

    # We use np.allclose for a robust floating-point comparison over the whole beam
    is_match = np.allclose(generated_Ey, Ey_target)

    print(f"\nFinal Check Equation: Is 'generated_Ey' equal to 'Ey_target' for all points?")
    if not is_match:
        print("Result: No. The generated Y-component does not match the target Y-component.")
        print("\nConclusion: It is impossible to generate an ARBITRARY vector beam because we")
        print("cannot independently control the two output polarization components with a single scalar input.")
    else:
        # This case is astronomically unlikely with a random system
        print("Result: Yes. By sheer coincidence, the random system happened to match the target.")
        print("This does not hold for an ARBITRARY target.")


if __name__ == '__main__':
    demonstrate_vector_beam_limitation()