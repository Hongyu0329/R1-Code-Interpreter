import math
from itertools import combinations, product

def get_divisors(n):
    """Computes all positive divisors of an integer n."""
    divs = set()
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divs.add(i)
            divs.add(n // i)
    return sorted(list(divs))

def get_element_orders(factors):
    """
    Calculates the set of orders of elements in a group G = Z_f1 x Z_f2 x ...
    'factors' is a list like [2, 3, 3] for Z_2 x Z_3 x Z_3.
    """
    if not factors:
        return {1}
    
    order_sets = [get_divisors(f) for f in factors]
    
    def lcm(a, b):
        if a == 0 or b == 0:
            return 0
        return abs(a * b) // math.gcd(a, b)

    all_orders = set()
    for combo in product(*order_sets):
        current_lcm = 1
        for order in combo:
            current_lcm = lcm(current_lcm, order)
        all_orders.add(current_lcm)
        
    return sorted(list(all_orders))

def get_antichains(poset_elements):
    """
    Finds all non-empty antichains in a poset defined by divisibility.
    An antichain is a subset where for any two distinct elements a, b,
    neither a divides b nor b divides a.
    """
    antichains = []
    elements = sorted(list(poset_elements))
    
    for i in range(1, len(elements) + 1):
        for subset in combinations(elements, i):
            is_antichain = True
            if len(subset) > 1:
                for j1 in range(len(subset)):
                    for j2 in range(len(subset)):
                        if j1 != j2:
                            if subset[j2] % subset[j1] == 0:
                                is_antichain = False
                                break
                    if not is_antichain:
                        break
            
            if is_antichain:
                antichains.append(frozenset(subset))
                
    return antichains

# There are two non-isomorphic Abelian groups of order 18:
# G1 = Z_18 (cyclic)
# G2 = Z_2 x Z_3 x Z_3
print("Step 1: Determine the set of element orders for each group.")

# For G1 = Z_18, orders are the divisors of 18.
orders_g1 = get_divisors(18)
print(f"Orders for G1 (Z_18): {orders_g1}")

# For G2 = Z_2 x Z_3 x Z_3
orders_g2 = get_element_orders([2, 3, 3])
print(f"Orders for G2 (Z_2 x Z_3 x Z_3): {orders_g2}")

print("\nStep 2: Find the number of unique eigenvalue sets for each group by counting antichains.")
antichains_g1 = get_antichains(orders_g1)
antichains_g2 = get_antichains(orders_g2)

num_sets_g1 = len(antichains_g1)
num_sets_g2 = len(antichains_g2)

print(f"Number of sets for G1 corresponds to non-empty antichains in {orders_g1}: {num_sets_g1}")
print(f"Number of sets for G2 corresponds to non-empty antichains in {orders_g2}: {num_sets_g2}")

print("\nStep 3: Calculate the total number of unique sets across both groups.")
# The total number of unique sets is the size of the union of the two sets of antichains.
total_unique_sets = set(antichains_g1) | set(antichains_g2)
num_total_unique = len(total_unique_sets)
num_intersection = num_sets_g1 + num_sets_g2 - num_total_unique

print("The total number of unique sets is the size of the union of the sets generated by G1 and G2.")
print("Using the principle of inclusion-exclusion, the final calculation is:")
print(f"|Sets from G1| + |Sets from G2| - |Intersection| = Total Unique Sets")
print(f"{num_sets_g1} + {num_sets_g2} - {num_intersection} = {num_total_unique}")

<<<9>>>