174[
void main() {
    // This program calculates 100! using minimal variable memory on the Wuxing computer.
    // The total memory consumed by variables is 174D.

    // --- Variable Declarations (Total Memory: 174D) ---

    // The result array stores the digits of 100! in reverse order.
    // 100! has 158 digits. We use an array of 160 for a safe margin.
    // Memory: 160 elements * 1D/digit = 160D
    digit result[160];

    // Tracks the current number of digits in the result (max ~158).
    // char (0-999) is the smallest type that fits. Memory: 3D
    char num_digits;

    // Loop counters. i goes up to 100, j goes up to ~159.
    // char (0-999) is the smallest type for both. Memory: 3D + 3D = 6D
    char i, j;
    
    // The carry for multiplication. Max value is (9*100+99)/10 = 99.
    // short (0-99) is the smallest type that fits. Memory: 2D
    short carry;

    // Temporary product for each step. Max value is 9*100+99 = 999.
    // char (0-999) is the smallest type that fits. Memory: 3D
    char product;

    // --- Initialization ---

    // Initialize result array to zeros, then set the value to 1.
    for (j = 0; j < 160; j++) {
        result[j] = 0;
    }
    result[0] = 1;
    num_digits = 1;

    // --- Factorial Calculation ---

    // Multiply the result by i for i from 2 to 100.
    for (i = 2; i <= 100; i++) {
        carry = 0;
        // Multiply each digit of the current number by i.
        for (j = 0; j < num_digits; j++) {
            product = result[j] * i + carry;
            result[j] = product % 10;
            carry = product / 10;
        }

        // If there's a carry left over, append it as new digits.
        while (carry > 0) {
            result[num_digits] = carry % 10;
            carry = carry / 10;
            num_digits++;
        }
    }

    // --- Output ---
    
    // Print the final result by reading the array in reverse.
    printf("100! = ");
    for (j = num_digits - 1; j >= 0; j--) {
        printf("%d", result[j]);
    }
    printf("\n");
}
]