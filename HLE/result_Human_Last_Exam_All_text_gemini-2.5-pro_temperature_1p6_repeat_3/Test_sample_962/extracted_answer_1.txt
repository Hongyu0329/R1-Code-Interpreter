The design is based on the Schnorr signature scheme over a cryptographic group `G` (e.g., an elliptic curve group) of prime order `q` with generator `g`. It requires two secure hash functions, `H_bind` and `H_chal`. The scheme consists of a one-time setup phase (DKG) and the two-round signing protocol.

**1. Prerequisites: Distributed Key Generation (DKG)**

Before signing, the `n` parties must execute a `(t, n)`-threshold DKG protocol, such as Pedersen VSS.
*   **Input:** Security parameter, `t`, `n`.
*   **Output:**
    *   A single group public key `PK`.
    *   For each party `i \in \{1, ..., n\}`, a secret key share `sk_i \in \mathbb{Z}_q`.
    *   (Optional but recommended) Public verification keys for each share, `PK_i = g^{sk_i}`.

The property of the DKG is that for any authorized subset `S` of `t` parties, their secret shares can be combined using Lagrange interpolation to reconstruct the master secret key `sk` (where `PK=g^{sk}`), i.e., `sk = \sum_{i \in S} \lambda_i \cdot sk_i`, where `\lambda_i` are the corresponding Lagrange coefficients.

**2. Two-Round Signing Protocol**

To sign a message `m`, a subgroup of `t` parties, denoted by the set `S`, engages in the following protocol.

**Round 1: Commitment**
Each party `i \in S` performs the following steps:
1.  Generate two private nonces by sampling them uniformly at random from `\mathbb{Z}_q`: `(d_i, e_i) \leftarrow \mathbb{Z}_q \times \mathbb{Z}_q`.
2.  Compute the corresponding public commitments: `D_i = g^{d_i}` and `E_i = g^{e_i}`.
3.  Broadcast the tuple of commitments `(D_i, E_i)` to all other parties in `S`.

**Round 2: Signing and Aggregation**
After every party `i \in S` has received the commitments `(D_j, E_j)` from all other parties `j \in S`, party `i` proceeds as follows:
1.  **Create Commitment List:** Form an ordered list of all received commitments `L = ((D_1, E_1), (D_2, E_2), ..., (D_t, E_t))`.
2.  **Compute Binding Factor:** Compute a non-interactive binding factor `b` which is the output of a hash function whose input includes all commitments from the first round, the group public key, and the message `m`.
    `b = H_bind(PK, L, m)`
3.  **Compute Aggregate Nonce Commitment:** Each party computes the group's aggregate nonce commitment `R`.
    *   First, compute the aggregate `D = \prod_{j \in S} D_j` and `E = \prod_{j \in S} E_j`.
    *   Then, compute `R = D \cdot E^b`.
4.  **Compute Challenge:** Compute the Schnorr-like challenge `c`.
    `c = H_chal(PK, R, m)`
5.  **Compute Partial Signature:**
    *   Calculate the Lagrange coefficient `\lambda_i` corresponding to party `i`'s public identifier within the set `S`.
    *   Compute the party's full effective nonce `k_i = d_i + b \cdot e_i \pmod q`.
    *   Compute the partial signature `z_i = k_i + c \cdot \lambda_i \cdot sk_i \pmod q`.
6.  **Broadcast Partial Signature:** Broadcast the partial signature `z_i` to an aggregator (which can be one of the participants or an external entity).

**Signature Aggregation**
The aggregator, upon receiving `t` partial signatures `z_j` from all parties `j \in S`:
1.  Computes the final signature value `z = \sum_{j \in S} z_j \pmod q`.
2.  The final, complete signature is the pair `\sigma = (R, z)`. `R` only needs to be computed once by the aggregator using the method from step 2.3.

**3. Verification**
Anyone with the group public key `PK`, the message `m`, and the signature `\sigma = (R, z)` can verify it.
1.  Compute the challenge `c = H_chal(PK, R, m)`.
2.  Check if the verification equation `g^z = R \cdot PK^c` holds. If it does, the signature is valid.