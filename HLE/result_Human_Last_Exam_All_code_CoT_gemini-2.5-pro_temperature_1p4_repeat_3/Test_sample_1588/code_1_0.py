import math

def get_prime_factorization(num):
    """
    Returns a dictionary of prime factors of num.
    e.g., get_prime_factorization(12) returns {2: 2, 3: 1}
    """
    factors = {}
    d = 2
    temp_num = num
    while d * d <= temp_num:
        while temp_num % d == 0:
            factors[d] = factors.get(d, 0) + 1
            temp_num //= d
        d += 1
    if temp_num > 1:
        factors[temp_num] = factors.get(temp_num, 0) + 1
    return factors

def mobius(n):
    """
    Computes the Mobius function mu(n).
    mu(n) = 1 if n is a square-free positive integer with an even number of prime factors.
    mu(n) = -1 if n is a square-free positive integer with an odd number of prime factors.
    mu(n) = 0 if n has a squared prime factor.
    """
    if n == 1:
        return 1
    
    factors = get_prime_factorization(n)
    for p in factors:
        if factors[p] > 1:
            return 0  # n has a squared prime factor
    
    # n is square-free
    if len(factors) % 2 == 1:
        return -1 # odd number of prime factors
    else:
        return 1 # even number of prime factors

def get_divisors(n):
    """
    Returns a sorted list of all positive divisors of n.
    """
    divs = set()
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divs.add(i)
            divs.add(n // i)
    return sorted(list(divs))

def calculate_bch_coeffs(n, k):
    """
    Calculates the number of nonzero coefficients of order n for k generators
    using Witt's formula and prints the steps.
    """
    print(f"The number of nonzero BCH coefficients of order n={n} for k={k} generators is given by Witt's formula:")
    print(f"L_{n}({k}) = (1/{n}) * Σ_{{d|{n}}} μ({n}/d) * {k}^d\n")

    divisors = get_divisors(n)
    print(f"The positive divisors of n={n} are: {divisors}\n")
    
    total_sum = 0
    sum_terms_str = []

    for d in divisors:
        m = n // d
        mu_m = mobius(m)
        k_d = k ** d
        term = mu_m * k_d
        
        print(f"Term for d={d}:")
        print(f"  μ({n}/{d}) * {k}^{d} = μ({m}) * {k_d} = {mu_m} * {k_d} = {term}")
        
        total_sum += term
        sum_terms_str.append(f"({term})" if term < 0 else str(term))

    result = total_sum // n
    
    print("\nSumming the terms:")
    equation = f"L_{n}({k}) = (1/{n}) * [ " + " + ".join(sum_terms_str) + " ]"
    print(equation)
    print(f"L_{n}({k}) = (1/{n}) * [ {total_sum} ]")
    print(f"L_{n}({k}) = {total_sum} / {n}")
    print(f"\nThe number of nonzero coefficients is: {result}")
    
    return result

if __name__ == '__main__':
    n_order = 10
    k_generators = 2
    
    final_answer = calculate_bch_coeffs(n_order, k_generators)
    # The final answer in the required format will be generated by the user's framework.
    # For a standalone script, one would print it like this:
    # print(f"<<<{final_answer}>>>")
