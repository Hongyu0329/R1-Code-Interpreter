import sys

# It's necessary to increase the recursion limit for demonstration purposes.
# The failing case will hit this limit, while the successful case will not.
sys.setrecursionlimit(2000)

class RecursiveDescentParser:
    """
    A simple Recursive Descent parser to demonstrate the effects of
    left recursion on a grammar.
    """
    def __init__(self, text):
        # We split the input string into a list of tokens (words).
        self.tokens = text.split()
        self.pos = 0

    def parse(self):
        """Attempts to parse the entire input string according to the top-level rule L."""
        # A successful parse must consume all tokens.
        if self.parse_L() and self.pos == len(self.tokens):
            return True
        return False

    def peek(self):
        """Looks at the next token without consuming it."""
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        return None

    def match(self, token):
        """If the next token matches the target, consumes it and returns True."""
        if self.peek() == token:
            self.pos += 1
            return True
        return False
    
    # Rule: L = S V C '.' EOF
    def parse_L(self):
        initial_pos = self.pos
        # All sub-rules must match in sequence.
        if self.parse_S() and self.parse_V() and self.parse_C() and self.match('.'):
            return True
        self.pos = initial_pos # Backtrack on failure
        return False

    # Rule: S = N | ADJ N | N ADJ
    # We implement this with an order that exposes the left-recursion problem.
    # By trying `ADJ N` first, we force a call to `parse_ADJ` immediately.
    def parse_S(self):
        # Alternative 1: ADJ N
        initial_pos = self.pos
        if self.parse_ADJ() and self.parse_N():
            return True
        self.pos = initial_pos # Backtrack

        # Alternative 2: N ADJ
        if self.parse_N() and self.parse_ADJ():
            return True
        self.pos = initial_pos # Backtrack

        # Alternative 3: N
        if self.parse_N():
            return True
        
        # All alternatives failed, backtrack fully
        self.pos = initial_pos 
        return False

    # N = 'frogs' | 'snakes'
    def parse_N(self):
        return self.match('frogs') or self.match('snakes')

    # V = 'jump' | 'swim'
    def parse_V(self):
        return self.match('jump') or self.match('swim')
        
    # ADJ = 'red' | 'or alike' | REC
    def parse_ADJ(self):
        initial_pos = self.pos
        # Match 'red'
        if self.match('red'):
            return True
            
        # Match 'or alike' (as two tokens)
        if self.match('or') and self.match('alike'):
            return True
        self.pos = initial_pos # Backtrack if only 'or' was matched

        # The left-recursive alternative. This is the source of the problem.
        if self.parse_REC():
            return True
            
        return False

    # REC = REC ADJ
    # This rule causes infinite recursion.
    def parse_REC(self):
        # A call to parse_REC() immediately calls itself, leading to infinite recursion.
        return self.parse_REC() and self.parse_ADJ()

    # C = 'well' | 'swiftly'
    def parse_C(self):
        return self.match('well') or self.match('swiftly')

def main():
    """Main function to run the analysis and print results."""
    print("--- Parser Demonstration and Statement Analysis ---")
    
    # Test Case 1: A sentence that succeeds
    sentence1 = "red frogs swim swiftly ."
    parser1 = RecursiveDescentParser(sentence1)
    print(f"\n1. Testing sentence: '{sentence1}'")
    try:
        result1 = parser1.parse()
        print(f"   Parser Result: {'Accepted' if result1 else 'Rejected'}")
        print("   Reason: The parser matches `ADJ` with 'red' and succeeds before trying the left-recursive `REC` rule.")
    except RecursionError:
        print("   Parser Result: Infinite recursion detected.")

    # Test Case 2: A sentence that causes infinite recursion
    sentence2 = "frogs swim swiftly ."
    parser2 = RecursiveDescentParser(sentence2)
    print(f"\n2. Testing sentence: '{sentence2}'")
    print(f"   (This is a valid sentence in the language via S -> N)")
    try:
        result2 = parser2.parse()
        print(f"   Parser Result: {'Accepted' if result2 else 'Rejected'}")
    except RecursionError:
        print(f"   Parser Result: Infinite recursion detected.")
        print("   Reason: To parse `S`, the parser first tries the `ADJ N` rule. The call to `parse_ADJ` on input 'frogs' fails to match 'red' or 'or alike', so it calls `parse_REC`, which causes an infinite loop.")

    print("\n--- Final Conclusion ---")
    print("The demonstration and analysis lead to the following conclusions about the answer choices:")
    print("A. Correct. The statement is a true fact about the language generated by the grammar.")
    print("B. Incorrect. The sentence is not in the language.")
    print("C. Incorrect. The sentence is not in the language.")
    print("D. Incorrect. The parser can be (and has been) implemented; it is just faulty for this grammar.")
    print("E. Incorrect. Statement A is correct.")

if __name__ == "__main__":
    main()
<<<A>>>