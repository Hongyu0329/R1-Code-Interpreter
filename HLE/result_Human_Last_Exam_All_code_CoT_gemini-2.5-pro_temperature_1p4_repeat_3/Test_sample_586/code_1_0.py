import re

def analyze_sgrna_candidates():
    """
    Analyzes potential sgRNA target sequences for CRISPR/spCas9 targeting.
    """
    # The full gene sequence provided by the user
    full_sequence = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTCAGAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGGTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"

    # Step 1: Isolate genomic regions
    parts = full_sequence.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]
    
    # Step 2: Define candidates from answer choices
    options_raw = {
        "A": "AGCGGTTTACTGAGACCCGG(TGG)", "B": "TCCGGCGGGTTTTCGAGTGGG",
        "C": "TTCATGCCCCTGGATGCGCT(TGG)", "D": "CAGGACCGGTTTCAGATGCG(CGG)",
        "E": "GCATCTGAAACCGGTCCTG(TGG)", "F": "GGAAGCAATCCTCCGAACGT(TGG)",
        "G": "ACGTTGCGAGGACAGAGTCA(AGG)", "H": "CCCTTTCACAAATCCTTCCT(TGG)",
        "I": "TTCACCCGCACCTTGAACGG(AGG)", "J": "CTTTCTTTCTTTCTTTCTTTC(TTT)",
        "K": "CTGCTCTACCCAATCGCCA(TGG)", "L": "TGCCTG(CGG)",
        "M": "TGCAAAGTAGATCGAGATGG(AGG)", "N": "ACAGTCCAGAAGGGCGATCA(AGG)",
        "O": "ATG(ACC)"
    }

    print("Analyzing sgRNA Candidates for Exon 2...\n")

    # Step 3: Analyze each candidate
    for letter, text in options_raw.items():
        print(f"--- Option {letter}: {text} ---")
        
        match = re.match(r"([A-Z]+)\(([A-Z]{3})\)", text)
        if not match:
            print("Status: INVALID - Malformed entry (format should be GUIDE(PAM)).\n")
            continue

        guide, pam = match.groups()
        full_target = guide + pam
        
        # Check location
        location_str = "Not Found"
        if exon2.find(full_target) != -1:
            location_str = f"Exon 2 at position {exon2.find(full_target)}"
        elif exon1.find(full_target) != -1:
            location_str = "Exon 1"
        elif intron.find(full_target) != -1:
            location_str = "Intron"
        
        print(f"Location: {location_str}")

        # Check for major issues
        is_valid = True
        notes = []
        if "Exon 2" not in location_str:
            is_valid = False
            notes.append("Target is not in Exon 2.")
        
        if not (len(guide) >= 19 and len(guide) <= 21):
            is_valid = False
            notes.append(f"Guide length is {len(guide)} nt (should be 19-21 nt).")
        
        if not pam.endswith("GG"):
            is_valid = False
            notes.append(f"PAM is '{pam}' (should be NGG).")

        if is_valid:
            # Perform detailed analysis only if it passes basic checks
            g_count = guide.count('G')
            c_count = guide.count('C')
            gc_content = (g_count + c_count) / len(guide) * 100
            print(f"Guide Length: {len(guide)} nt")
            print(f"PAM: {pam} (Valid)")
            print(f"GC Content Equation: ({g_count} G + {c_count} C) / {len(guide)} nt = {gc_content:.1f}%")
            if gc_content < 40 or gc_content > 80:
                notes.append("GC content is outside the ideal 40-80% range.")
            if re.search(r"(AAAA|TTTT|GGGG|CCCC)", guide):
                notes.append("Contains a homopolymer run (>=4), which can be problematic.")
            
            print(f"Notes: {', '.join(notes) if notes else 'Looks good.'}")
            print("Status: VALID CANDIDATE\n")
        else:
            print(f"Notes: {', '.join(notes)}")
            print("Status: INVALID\n")

    # Step 4: Final Recommendation
    print("--- Conclusion ---")
    print("Based on the analysis, the most suitable sgRNA target sequence is from option E.")
    print("Final Recommended Target: GCATCTGAAACCGGTCCTG(TGG)")
    print("\nReasoning:")
    print("1. Location: The sequence GCATCTGAAACCGGTCCTGTGG is correctly located within the target second exon.")
    print("2. Length: The guide sequence 'GCATCTGAAACCGGTCCTG' is 19 nucleotides, which is an appropriate length.")
    print("3. PAM: It is followed by a valid TGG PAM.")
    print("4. GC Content: The GC content is 47.4%, which is ideal for sgRNA function.")
    print("5. Specificity: The sequence is complex and lacks obvious repetitive elements, suggesting a lower risk of off-target effects compared to other options.")
    print("\nCandidate K, CTGCTCTACCCAATCGCCA(TGG), is also a valid choice but is considered slightly less ideal due to the presence of a 'CCC' homopolymer.")

analyze_sgrna_candidates()
<<<E>>>