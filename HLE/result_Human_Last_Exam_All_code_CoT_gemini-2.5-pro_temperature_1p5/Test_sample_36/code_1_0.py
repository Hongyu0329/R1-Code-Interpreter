import math
from itertools import product

def lcm(a, b):
    """Compute the least common multiple of a and b."""
    if a == 0 or b == 0:
        return 0
    return abs(a*b) // math.gcd(a, b)

def get_element_orders(group_structure):
    """
    Calculates the set of possible element orders for a group given by
    the product of cyclic groups, e.g., Z_n1 x Z_n2 x ... is represented as [n1, n2, ...].
    """
    orders = set()
    # Get all divisors for each component cycle
    divisor_sets = []
    for n_i in group_structure:
        divs = {d for d in range(1, n_i + 1) if n_i % d == 0}
        divisor_sets.append(list(divs))
    
    # The order of an element (g1, g2, ...) is lcm(ord(g1), ord(g2), ...)
    for order_combo in product(*divisor_sets):
        current_lcm = 1
        for order in order_combo:
            current_lcm = lcm(current_lcm, order)
        orders.add(current_lcm)
        
    return sorted(list(orders))

def get_antichains(divisors):
    """
    Finds all antichains in a set of numbers, ordered by divisibility.
    An antichain is a subset where for any two distinct elements, neither divides the other.
    Returns a set of frozensets, where each frozenset is an antichain.
    """
    antichains = set()
    n = len(divisors)
    # Iterate through all non-empty subsets of the divisors
    for i in range(1, 1 << n):
        subset = [divisors[j] for j in range(n) if (i >> j) & 1]
        
        is_antichain = True
        if len(subset) > 1:
            # Check the antichain property for all pairs in the subset
            for k1 in range(len(subset)):
                for k2 in range(k1 + 1, len(subset)):
                    d1, d2 = subset[k1], subset[k2]
                    if d1 % d2 == 0 or d2 % d1 == 0:
                        is_antichain = False
                        break
                if not is_antichain:
                    break
        
        if is_antichain:
            antichains.add(frozenset(subset))
            
    return antichains

# The two non-isomorphic Abelian groups of order 18 are G1 = Z_18 and G2 = Z_2 x Z_3 x Z_3
groups = {
    "G1 (Z_18)": [18],
    "G2 (Z_2 x Z_3 x Z_3)": [2, 3, 3]
}

total_unique_antichains = set()
group_results = {}

print("Step 1: Determine the structure of eigenvalue sets for each group.")
print("The unique sets of eigenvalues S(rho) are generated by unions of groups of roots of unity {U_d}.")
print("Each unique union corresponds to an antichain on the set of possible orders {d}.\n")

for name, structure in groups.items():
    print(f"Analyzing group {name}:")
    
    # The possible orders 'd' are the possible orders of elements in the group.
    orders = get_element_orders(structure)
    print(f"  - The possible character orders {d} are: {orders}")
    
    # The unique sets S(rho) correspond to the antichains on this set of orders.
    antichains = get_antichains(orders)
    group_results[name] = len(antichains)
    total_unique_antichains.update(antichains)
    
    print(f"  - This group can form {len(antichains)} unique sets of eigenvalues.\n")

print("Step 2: Combine results to find the total number of unique sets.")
num_g1 = group_results["G1 (Z_18)"]
num_g2 = group_results["G2 (Z_2 x Z_3 x Z_3)"]
total_num = len(total_unique_antichains)

print(f"Number of sets from G1 = {num_g1}")
print(f"Number of sets from G2 = {num_g2}")
print("The collection of sets from G2 is a subset of the collection from G1.")
print(f"The total number of unique sets is the size of the union of these two collections.")
print(f"Total unique sets = |(Sets from G1) U (Sets from G2)| = {total_num}")
print("\nTherefore, there are 9 unique sets S(rho) cap D.")
print(f"<<<{total_num}>>>")