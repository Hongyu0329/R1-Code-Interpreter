import numpy as np

# This problem explores a property of a rank-1 matrix approximation problem.
# We want to know for which maximal dimension 'd' the entire Pareto front
# of the approximation errors can be generated by scalarization, given that
# the data matrix X has non-negative entries.

# The multi-objective problem is to minimize the squared errors for each row:
# epsilon_i^2(w) = ||x_i - x_iww^T||^2 for i=1..n
# which is equivalent to maximizing the vector of squared projections:
# ( (x_1*w)^2, (x_2*w)^2, ..., (x_n*w)^2 )

# Scalarization is guaranteed to work if the set of achievable objective vectors Y is convex.
# Y = { ( (x_1*w)^2, ..., (x_n*w)^2 ) | ||w|| = 1 }

# For d=2, Y is always an ellipse, which is a convex set.
# We test if this holds for d=3 by trying to find a counter-example.

# Define the matrix X (n x d) = (3 x 3) with non-negative entries.
X = np.array([[1., 1., 0.],
              [0., 1., 1.],
              [1., 0., 1.]])
n, d = X.shape

print(f"Testing with d={d}, n={n} to see if scalarization is always sufficient.")
print("Using counter-example matrix X:")
print(X)

# Define the function that maps a vector w to the objective space.
def F(w, X_):
    projections = X_.dot(w)
    return projections**2

# We will show Y is not convex by finding two points ya and yb in Y,
# and showing that their midpoint is not in Y.

# Point a: choose w_a = (1, 0, 0)
w_a = np.array([1., 0., 0.])
y_a = F(w_a, X)
print(f"\nLet w_a = {w_a}. This is a unit vector.")
print(f"The corresponding objective vector is y_a = {y_a}")

# Point b: choose w_b = (0, 1, 0)
w_b = np.array([0., 1., 0.])
y_b = F(w_b, X)
print(f"\nLet w_b = {w_b}. This is a unit vector.")
print(f"The corresponding objective vector is y_b = {y_b}")

# The midpoint of y_a and y_b.
midpoint = (y_a + y_b) / 2
print(f"\nThe midpoint of y_a and y_b is {midpoint}")

print("\nTo check if this midpoint is in Y, we must find a unit vector w=(w1,w2,w3) such that F(w) equals the midpoint.")
print("This implies solving the system:")
print("(w1 + w2)^2 = 1.0")
print("(w2 + w3)^2 = 0.5")
print("(w1 + w3)^2 = 0.5")
print("with the constraint: w1^2 + w2^2 + w3^2 = 1.0")

# From (w2 + w3)^2 = 0.5 and (w1 + w3)^2 = 0.5, we have w1+w3 = +/-(w2+w3)
# Case 1: w1 + w3 = w2 + w3  => w1 = w2
# Substitute into the first eq: (2*w1)^2 = 1 => w1 = +/- 0.5. So w2 = w1.
# (w1+w2)^2=1 implies w1,w2 must have same sign. Let w1=w2=0.5.
# From (0.5 + w3)^2 = 0.5 => w3 = -0.5 +/- sqrt(0.5)
# Check the norm for w = (0.5, 0.5, -0.5 +/- sqrt(0.5)):
w1, w2 = 0.5, 0.5
w3_plus = -0.5 + np.sqrt(0.5)
w3_minus = -0.5 - np.sqrt(0.5)
norm_sq_plus = w1**2 + w2**2 + w3_plus**2
norm_sq_minus = w1**2 + w2**2 + w3_minus**2
print("\nAnalysis of Case 1 (w1=w2):")
print(f"   The squared norm of w would be {norm_sq_plus:.4f} or {norm_sq_minus:.4f}")
print("   Neither equals 1.0.")

# Case 2: w1 + w3 = -(w2 + w3) => w1 + w2 + 2*w3 = 0
# From first eq, w1 + w2 = +/- 1.
# This gives 2*w3 = -(+/-1) => w3 = -/+ 0.5.
# Let w1+w2=1 and w3=-0.5. From (w2 - 0.5)^2 = 0.5, w2 = 0.5 +/- sqrt(0.5).
# Then w1 = 1 - w2 = 0.5 -/+ sqrt(0.5).
# Check the norm for w = (0.5 -/+ sqrt(0.5), 0.5 +/- sqrt(0.5), -0.5):
w3 = -0.5
w2_p = 0.5 + np.sqrt(0.5)
w1_m = 0.5 - np.sqrt(0.5)
norm_sq_case2 = w1_m**2 + w2_p**2 + w3**2
print("\nAnalysis of Case 2 (w1+w2+2w3=0):")
print(f"   The squared norm of w would be {norm_sq_case2:.4f}")
print("   This does not equal 1.0 either.")

print("\nConclusion: No unit vector w can produce the midpoint. The set Y is not convex.")
print("Since we found a counter-example for d=3, and the property holds for d=2, the largest value of d is 2.")
