import math

def get_power_subgroup_representation(k):
    """
    Computes a canonical string representation for the power subgroup G^k of Q_128.
    
    Q_128 = <x, y | x^64 = 1, x^32 = y^2, y^-1*x*y = x^-1>
    G^k = <g^k | g in Q_128>
    """
    # The set of generators for G^k is determined by { (x^i)^k } and { (x^i*y)^k }.

    # Part 1: Generators from powers of x^i elements
    # This generates <x^gcd(k, 64)>.
    gen_power_from_x = math.gcd(k, 64)

    # Part 2: Generators from powers of x^i*y elements, which depends on k mod 4.
    rem_k_mod_4 = k % 4
    
    if rem_k_mod_4 == 1 or rem_k_mod_4 == 3: # k is odd
        # The set { (x^i*y)^k } generates the whole group Q_128.
        return "Q_128"
        
    elif rem_k_mod_4 == 2:
        # The set { (x^i*y)^k } only contains x^32.
        # The group is <x^gcd(k, 64), x^32>. gcd(k, 64) for k=2(mod 4) is 2.
        # Thus we have <x^2, x^32>, which is just <x^2>.
        return "<x^2>"

    elif rem_k_mod_4 == 0:
        # The set { (x^i*y)^k } only contains the identity element.
        # The group is just <x^gcd(k, 64)>.
        if gen_power_from_x == 64:
             return "<1>" # Trivial group
        return f"<x^{gen_power_from_x}>"


def solve():
    """
    Finds and counts the number of distinct power subgroups in Q_128.
    """
    print("This script calculates the number of power subgroups in Q_128.")
    print("A power subgroup G^k is generated by the k-th powers of all elements in G.\n")
    
    found_subgroups = set()
    
    # We analyze G^k based on k. It's sufficient to check k values that produce
    # all possible values for gcd(k, 64) and cover all k mod 4 cases.
    
    # Case 1: k is odd. Let's use k=1.
    sg_odd = get_power_subgroup_representation(1)
    found_subgroups.add(sg_odd)
    
    # Case 2: k is 2 mod 4. Let's use k=2.
    sg_2_mod_4 = get_power_subgroup_representation(2)
    found_subgroups.add(sg_2_mod_4)
    
    # Case 3: k is a multiple of 4.
    # We check k values that generate all possible gcds with 64.
    k_vals_for_case3 = [4, 8, 12, 16, 20, 24, 28, 32, 64]
    for k_val in k_vals_for_case3:
        found_subgroups.add(get_power_subgroup_representation(k_val))

    num_from_odd = 1
    num_from_2mod4 = 1
    num_from_0mod4 = len(found_subgroups) - num_from_odd - num_from_2mod4

    print("The distinct power subgroups are:")
    # Print sorted for a canonical order.
    for sg in sorted(list(found_subgroups), key=lambda s: "Q" if s.startswith("Q") else ("z" if s=="<1>" else s)):
        print(f"  {sg}")
    
    count = len(found_subgroups)
    print("\nSummary of the count:")
    print(f"From odd k: {num_from_odd} subgroup ({sg_odd})")
    print(f"From k=2(mod 4): {num_from_2mod4} subgroup ({sg_2_mod_4})")
    print(f"From k=0(mod 4): {num_from_0mod4} subgroups")
    
    print(f"\nThe final calculation is:")
    print(f"{num_from_odd} + {num_from_2mod4} + {num_from_0mod4} = {count}")
    
    print(f"\nThere are a total of {count} distinct power subgroups in Q_128.")

if __name__ == '__main__':
    solve()
