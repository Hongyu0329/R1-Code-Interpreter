# Plan:
# 1. Start with the number of configuration variables for x_mu and w_mu.
# 2. For each variable, we need initial position and velocity, so multiply by 2.
# 3. Subtract dimensions for each constraint on the initial data.
# 4. The constraint w*w=1 removes 1 dimension from w(0).
# 5. The consequence w*w_dot=0 removes 1 dimension relating w(0) and w_dot(0).
# 6. The conservation of momentum p_mu leads to the constraint p*w=0.
#    This reduces the effective configuration space of w from a 3-sphere to a 2-sphere,
#    so the degrees of freedom for w are 2, not 3.
#    This means the effective dimension of the configuration space is dim(x) + dim(w) = 4 + 2 = 6.
# 7. The phase space dimension is 2 * 6 = 12.
# 8. Reparametrization invariance is a gauge symmetry, which introduces one first-class constraint.
#    This constraint reduces the physical phase space dimension by 2.
# 9. The final number of initial data is the dimension of the physical phase space.

num_x_vars = 4
num_w_vars = 4
total_vars = num_x_vars + num_w_vars
print(f"Initial number of variables in naive count: {total_vars}")

# In a Cauchy problem, we specify initial positions and velocities
naive_initial_data = 2 * total_vars
print(f"Naive number of initial data (positions and velocities): {naive_initial_data}")

# Step 1: Effective dimension of the configuration space
# x_mu lives in a 4D space.
dim_x_config = 4
# w_mu is constrained by w^2=1, so it lives on a 3D manifold.
# Further, p*w=0 where p is the constant conjugate momentum to x.
# This constrains w to a 2D sphere.
dim_w_config = 2
dim_effective_config_space = dim_x_config + dim_w_config
print(f"Dimension of the effective configuration space (x lives in R^4, w lives in S^2): {dim_effective_config_space}")

# Step 2: Dimension of the corresponding phase space
# The phase space is the cotangent bundle of the configuration space.
dim_phase_space = 2 * dim_effective_config_space
print(f"Dimension of the effective phase space: {dim_phase_space}")

# Step 3: Account for gauge symmetries
# The action is reparametrization invariant, which corresponds to 1 gauge symmetry.
# Each gauge symmetry is generated by a first-class constraint in the Hamiltonian formalism.
num_first_class_constraints = 1
print(f"Number of first-class constraints from gauge invariance: {num_first_class_constraints}")

# Each first-class constraint removes 2 dimensions from the phase space.
dim_reduction = 2 * num_first_class_constraints
print(f"Reduction in phase space dimension due to gauge invariance: {dim_reduction}")

# Step 4: Calculate the dimension of the physical phase space
# This dimension is the number of required initial data.
num_initial_data = dim_phase_space - dim_reduction
print(f"The number of initial data is the dimension of the physical phase space.")
print(f"Calculation: {dim_phase_space} - {dim_reduction} = {num_initial_data}")