import decimal
import random

def is_prime(n, k=5):
    """
    Tests if a number is prime using the Miller-Rabin primality test.
    This is a probabilistic test, but highly reliable for a sufficient number of rounds (k).
    It's necessary because the numbers we are testing are extremely large.
    """
    if n < 2:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False

    # Write n as 2^r * d + 1
    d = n - 1
    r = 0
    while d % 2 == 0:
        d //= 2
        r += 1

    # Perform k rounds of testing
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, d, n)  # Computes (a^d) % n
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

def solve_riddle():
    """
    Solves the riddle by finding the 6th prime in the sequence of concatenated
    digits of Euler's number (e) and verifying its final digits.
    """
    # Set precision for the decimal calculation. The 6th prime is 786 digits long,
    # so we need a high precision. 1000 is safe.
    decimal.getcontext().prec = 1000

    # Calculate Euler's number, e
    e_val = decimal.Decimal(1).exp()

    # Create the string of digits by taking the string representation of e and removing the decimal point
    digit_string = str(e_val).replace('.', '')

    primes_found = []
    
    # Iterate through the string of digits, creating longer numbers each time
    for i in range(1, len(digit_string) + 1):
        candidate_str = digit_string[:i]
        
        # To optimize, only test if the candidate is longer than the last found prime
        if len(primes_found) > 0 and len(candidate_str) <= len(str(primes_found[-1])):
            continue
            
        candidate = int(candidate_str)
        
        if is_prime(candidate):
            primes_found.append(candidate)
            if len(primes_found) == 6:
                break # Stop after finding the 6th prime

    print("The irrational number is Euler's number, e.")
    print("The sequence of primes is generated by concatenating its digits (271828...).")
    print("-" * 30)

    # Output the numbers from the sequence and the final equation
    p1, p2, p3, p4, p5, p6 = primes_found
    print(f"The 1st prime in the sequence is: {p1}")
    print(f"The 2nd prime in the sequence is: {p2}")
    print(f"The 3rd prime in the sequence is: {p3}")
    print(f"The 4th prime in the sequence is: {p4}")
    print(f"The 5th prime in the sequence is: {p5}")
    print(f"The 6th prime in the sequence is: {p6}")

    print("\nThe final number verification is shown by this equation:")
    # The equation involves the 6th prime, the modulus (1,000,000), and the result
    final_number = p6
    modulus = 1000000
    result = final_number % modulus
    
    print(f"{final_number} mod {modulus} = {result}")

# Run the solver
solve_riddle()