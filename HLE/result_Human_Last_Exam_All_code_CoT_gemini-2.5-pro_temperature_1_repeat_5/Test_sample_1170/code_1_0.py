def solve_prime_tt_ideals():
    """
    This function implements the logic described in the plan to determine which of the 20 objects
    generate a prime tt-ideal and how many primes are not generated by any of them.
    """

    # Define the properties of the base objects regarding their membership in the prime ideals P1 and P2.
    # A 'True' value means the object belongs to the corresponding ideal.
    # P1 is the ideal of objects with acyclic restriction.
    # P2 is the ideal of objects with acyclic orbits.
    in_p1_base = {
        'k': False,          # 1. k(0)
        'kCp': False,        # 2. kC_p(0)
        'Vp-1': False,       # 3. [p-1](0)
        'R': False,          # 4. rad(kC_p)
        'R_gap1': False,     # 5. gap^1(rad(kC_p))
        'R_gapp-1': False,   # 6. gap^{p-1}(rad(kC_p))
        'T': True,           # 7. cone(tau)
        'S': False,          # 15. S
    }

    in_p2_base = {
        'k': False,
        'kCp': False,
        'Vp-1': True,
        'R': True,
        'R_gap1': False,
        'R_gapp-1': False,
        'T': False,
        'S': True,
    }

    # The 20 objects are represented as tuples of their base components.
    # Tensor powers of an object have the same ideal membership as the object itself.
    objects = {
        1: ('k',),
        2: ('kCp',),
        3: ('Vp-1',),
        4: ('R',),
        5: ('R_gap1',),
        6: ('R_gapp-1',),
        7: ('T',),
        8: ('T',),  # cone(tau)^2
        9: ('T',),  # cone(tau)^{p-1}
        10: ('T',), # cone(tau)^p
        11: ('kCp', 'T'),
        12: ('R', 'T'),
        13: ('R_gap1', 'T'),
        14: ('R_gapp-1', 'T'),
        15: ('S',),
        16: ('S', 'kCp'),
        17: ('S', 'R'),
        18: ('S', 'T'),
        19: ('S', 'R_gap1'),
        20: ('S', 'R_gapp-1'),
    }

    def check_membership(obj_tuple):
        """Checks membership of a composite object in P1 and P2."""
        is_in_p1 = any(in_p1_base[part] for part in obj_tuple)
        is_in_p2 = any(in_p2_base[part] for part in obj_tuple)
        return is_in_p1, is_in_p2

    generator_indices = []
    generated_primes = set()

    for i in range(1, 21):
        obj_tuple = objects[i]
        is_in_p1, is_in_p2 = check_membership(obj_tuple)

        minimal_prime = None
        if is_in_p1 and is_in_p2:
            # Object is in P1 and P2, so it's in P3. Minimal prime is P3.
            minimal_prime = 'P3'
        elif is_in_p1:
            # Object is in P1 but not P2. Minimal prime is P1.
            minimal_prime = 'P1'
        elif is_in_p2:
            # Object is in P2 but not P1. Minimal prime is P2.
            minimal_prime = 'P2'
        
        # If a unique minimal prime exists, the object generates it.
        if minimal_prime:
            generator_indices.append(i)
            generated_primes.add(minimal_prime)

    # The total number of prime ideals is 3 (P1, P2, P3).
    total_primes = 3
    primes_not_generated = total_primes - len(generated_primes)

    # Sort the indices and format the output string as requested.
    result_list = sorted(generator_indices)
    output_str = ",".join(map(str, result_list))
    output_str += f";{primes_not_generated}"
    
    print(output_str)

solve_prime_tt_ideals()