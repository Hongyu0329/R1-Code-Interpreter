{
  "question": "You are near the money bubble with 16bb UTG1. What hand should you jam?\n\nAnswer Choices:\nA. QJs\nB. None of these \nC. 99\nD. AJo\nE. AKo\nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>.",
  "response_list": [
    "To determine the best hand to jam all-in, we need to consider our situation carefully. We are in an early position (UTG+1) with a 16bb stack, which is a typical \"shove-or-fold\" stack size. The crucial factor is that we are near the money bubble. This means our opponents will likely fold more often (giving us \"fold equity\"), but when they do call, they will have very strong hands.\n\nOur goal is to choose the hand that performs best when we get called. The best way to determine this is to calculate our hand's \"equity\" (our chance of winning at showdown) against a likely calling range.\n\n**Plan:**\n1.  **Define a Villain Calling Range:** Given the bubble pressure and our early position, a reasonable opponent will only call our 16bb shove with a premium hand range. We'll assume a tight range of **TT+, AQs+, and AKo**.\n2.  **Select Hero Hands:** We will test the hand options provided: QJs, 99, AJo, and AKo.\n3.  **Calculate Equity:** We will use a Python script to run a Monte Carlo simulation. This script will:\n    *   For each of our possible hands, it will simulate thousands of showdowns against each hand in the villain's range.\n    *   It will account for \"blocker\" effects (e.g., if we hold an Ace, the opponent is less likely to have Aces).\n    *   It will calculate a weighted average equity for each of our hands against the villain's entire range.\n4.  **Conclusion:** The hand with the highest weighted average equity is the most profitable and therefore the best hand to shove.\n\nThe following Python code will execute this plan.\n\n```python\nimport itertools\nimport random\nfrom collections import defaultdict\n\ndef get_hand_rank(hand):\n    \"\"\"Calculates the rank of a 5-card hand.\"\"\"\n    if len(hand) != 5:\n        raise ValueError(\"Hand must contain 5 cards.\")\n    \n    values = sorted([int(r) for r in '..23456789TJQKA'.index(c[0])] for c in hand)\n    ranks = [v[0] for v in values]\n    suits = [c[1] for c in hand]\n    \n    is_flush = len(set(suits)) == 1\n    # Straight check, including A-5\n    is_straight = (max(ranks) - min(ranks) == 4 and len(set(ranks)) == 5) or (ranks == [2, 3, 4, 5, 14])\n\n    if is_straight and is_flush:\n        return (8, ranks[-1])  # Straight Flush\n    \n    counts = defaultdict(int)\n    for r in ranks:\n        counts[r] += 1\n    \n    # Sort ranks by count, then by rank value\n    sorted_ranks = sorted(counts.keys(), key=lambda r: (counts[r], r), reverse=True)\n    \n    if counts[sorted_ranks[0]] == 4:\n        return (7, sorted_ranks[0], sorted_ranks[1])  # Four of a Kind\n    \n    if counts[sorted_ranks[0]] == 3 and counts[sorted_ranks[1]] == 2:\n        return (6, sorted_ranks[0], sorted_ranks[1])  # Full House\n        \n    if is_flush:\n        return (5, tuple(sorted(ranks, reverse=True))) # Flush\n        \n    if is_straight:\n        # Handle A-5 straight high card (5)\n        if ranks == [2, 3, 4, 5, 14]:\n            return (4, 5)\n        return (4, ranks[-1])  # Straight\n\n    if counts[sorted_ranks[0]] == 3:\n        kickers = tuple(sorted([r for r in sorted_ranks[1:]], reverse=True))\n        return (3, sorted_ranks[0]) + kickers # Three of a Kind\n\n    if counts[sorted_ranks[0]] == 2 and counts[sorted_ranks[1]] == 2:\n        kicker = sorted_ranks[2]\n        pairs = tuple(sorted([sorted_ranks[0], sorted_ranks[1]], reverse=True))\n        return (2, pairs, kicker) # Two Pair\n\n    if counts[sorted_ranks[0]] == 2:\n        kickers = tuple(sorted([r for r in sorted_ranks[1:]], reverse=True))\n        return (1, sorted_ranks[0]) + kickers # One Pair\n\n    return (0, tuple(sorted(ranks, reverse=True))) # High Card\n\ndef get_best_hand(cards):\n    \"\"\"Finds the best 5-card hand from a list of 7 cards.\"\"\"\n    return max(get_hand_rank(combo) for combo in itertools.combinations(cards, 5))\n\ndef calculate_equity(hero_hand, villain_hand, num_simulations=10000):\n    \"\"\"Monte Carlo simulation to calculate equity.\"\"\"\n    deck = {r + s for r in '23456789TJQKA' for s in 'shdc'}\n    deck -= set(hero_hand)\n    deck -= set(villain_hand)\n    \n    wins = 0\n    ties = 0\n\n    for _ in range(num_simulations):\n        board = random.sample(list(deck), 5)\n        hero_best = get_best_hand(hero_hand + board)\n        villain_best = get_best_hand(villain_hand + board)\n\n        if hero_best > villain_best:\n            wins += 1\n        elif hero_best == villain_best:\n            ties += 1\n            \n    return (wins + ties / 2) / num_simulations\n\ndef get_combos(hand_str, hero_hand=[]):\n    \"\"\"Get all card combinations for a hand string like 'AKs' or 'TT'.\"\"\"\n    ranks = '23456789TJQKA'\n    suits = 'shdc'\n    r1, r2 = hand_str[0], hand_str[1]\n    \n    # Remove hero's cards from potential combos\n    blocked_cards = set(hero_hand)\n    \n    combos = []\n    if r1 == r2: # Pocket Pair\n        combos = [tuple(sorted(c)) for c in itertools.combinations([r1 + s for s in suits], 2)]\n    elif len(hand_str) == 3 and hand_str[2] == 's': # Suited\n        combos = [tuple(sorted((r1 + s, r2 + s))) for s in suits]\n    else: # Offsuit\n        combos = [tuple(sorted((r1 + s1, r2 + s2))) for s1 in suits for s2 in suits if s1 != s2]\n\n    # Filter out combos that use a blocked card\n    valid_combos = [c for c in combos if not (c[0] in blocked_cards or c[1] in blocked_cards)]\n    return valid_combos\n\ndef main():\n    # --- Configuration ---\n    hero_options = {\n        \"QJs\": ['Qh', 'Jh'],\n        \"99\": ['9h', '9s'],\n        \"AJo\": ['Ah', 'Jd'],\n        \"AKo\": ['Ah', 'Kd'],\n    }\n    \n    # Villain's tight calling range on the bubble\n    villain_range_notation = ['TT', 'JJ', 'QQ', 'KK', 'AA', 'AQs', 'AKo']\n    \n    results = {}\n    print(\"Calculating showdown equity for each hand vs a tight bubble calling range (TT+, AQs+, AKo)\\n\")\n\n    for hero_name, hero_cards in hero_options.items():\n        print(f\"--- Analyzing Hero Hand: {hero_name} ({''.join(hero_cards)}) ---\")\n        \n        total_weighted_equity = 0\n        total_combos = 0\n        \n        equity_details = []\n\n        for hand_notation in villain_range_notation:\n            villain_combos = get_combos(hand_notation, hero_hand=hero_cards)\n            num_combos = len(villain_combos)\n            \n            if num_combos == 0:\n                continue\n\n            # Use the first valid combo as a representative for the equity calculation\n            representative_villain_hand = list(villain_combos[0])\n            equity = calculate_equity(hero_cards, representative_villain_hand, num_simulations=2000) # Lower sims for speed\n            \n            total_weighted_equity += equity * num_combos\n            total_combos += num_combos\n            equity_details.append({'notation': hand_notation, 'equity': equity, 'combos': num_combos})\n\n        average_equity = total_weighted_equity / total_combos if total_combos > 0 else 0\n        results[hero_name] = average_equity\n        \n        print(f\"Average Equity for {hero_name}: {average_equity:.2%}\\n\")\n\n    # Find and print the best hand\n    best_hand = max(results, key=results.get)\n    print(\"--- Conclusion ---\")\n    print(\"Based on the simulations, the hand with the highest equity when called is:\")\n    for hand, equity in sorted(results.items(), key=lambda item: item[1], reverse=True):\n        print(f\"{hand}: {equity:.2%}\")\n        \n    print(f\"\\nThe best hand to jam is {best_hand} because it has the highest profitability in a showdown.\")\n\n    # Fulfilling request to show the final equation for the best hand\n    print(f\"\\nExample of the final weighted average equity calculation for {best_hand}:\")\n    hero_cards = hero_options[best_hand]\n    equation_parts = []\n    total_combos = 0\n    total_weighted_equity = 0\n\n    for hand_notation in villain_range_notation:\n        villain_combos = get_combos(hand_notation, hero_hand=hero_cards)\n        num_combos = len(villain_combos)\n        if num_combos > 0:\n            equity = calculate_equity(hero_cards, list(villain_combos[0]), num_simulations=2000)\n            equation_parts.append(f\"({equity:.3f} * {num_combos} combos of {hand_notation})\")\n            total_combos += num_combos\n            total_weighted_equity += equity * num_combos\n\n    final_equity = total_weighted_equity / total_combos\n    equation_str = \" + \".join(equation_parts)\n    print(f\"({equation_str}) / {total_combos} total combos = {final_equity:.2%}\")\n\n\nif __name__ == '__main__':\n    main()\n\n```\n<<<E>>>"
  ],
  "user_prompt_list": [
    "You are a helpful AI assistant. Solve tasks using your coding skills.\n    In the following cases, suggest python code (in a python coding block) or shell script (in a sh coding block) for the user to execute.\n    Don't include multiple code blocks in one response, only include one in the response. Do not ask users to copy and paste the result. Instead, use 'print' function for the output when relevant.\n    Think the task step by step if you need to. If a plan is not provided, explain your plan first. You can first output your thinking steps with texts and then the final python code.\n    Remember in the final code you still need to output each number in the final equation!\n    Start the python block with ```python\n\n    You are near the money bubble with 16bb UTG1. What hand should you jam?\n\nAnswer Choices:\nA. QJs\nB. None of these \nC. 99\nD. AJo\nE. AKo\nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>."
  ],
  "system_message": ""
}