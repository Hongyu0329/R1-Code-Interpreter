import re

def analyze_sgrna_options():
    """
    This script analyzes potential sgRNA target sequences for spCas9
    based on location, PAM sequence, length, and GC content.
    """
    full_seq = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTTCAAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGVTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"
    
    # In case of copy-paste errors, fix potential split markers
    full_seq = full_seq.replace('V', '^')
    parts = full_seq.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]

    options = {
        "A": "AGCGGTTTACTGAGACCCGG(TGG)", "B": "TCCGGCGGGTTTTCGAGTGGG",
        "C": "TTCATGCCCCTGGATGCGCT(TGG)", "D": "CAGGACCGGTTTCAGATGCG(CGG)",
        "E": "GCATCTGAAACCGGTCCTG(TGG)", "F": "GGAAGCAATCCTCCGAACGT(TGG)",
        "G": "ACGTTGCGAGGACAGAGTCA(AGG)", "H": "CCCTTTCACAAATCCTTCCT(TGG)",
        "I": "TTCACCCGCACCTTGAACGG(AGG)", "J": "CTTTCTTTCTTTCTTTCTTTC(TTT)",
        "K": "CTGCTCTACCCAATCGCCA(TGG)", "L": "TGCCTG(CGG)",
        "M": "TGCAAAGTAGATCGAGATGG(AGG)", "N": "ACAGTCCAGAAGGGCGATCA(AGG)",
        "O": "ATG(ACC)"
    }

    print("--- sgRNA Target Analysis ---\n")
    
    best_candidate = None

    for key, value in options.items():
        print(f"Option {key}: {value}")
        
        # Parse target and PAM from the string
        match = re.match(r"([A-Z]+)\(([A-Z]+)\)", value)
        if match:
            target, pam = match.groups()
        else: # Handle cases without parentheses
            target, pam = value, "N/A"

        # --- Analysis ---
        # 1. Location
        full_target_seq = target + pam
        location = "Not Found"
        if full_target_seq in exon2:
            location = "Exon 2 (Correct)"
        elif full_target_seq in exon1:
            location = "Exon 1 (Incorrect)"
        elif full_target_seq in intron:
            location = "Intron (Incorrect)"
        
        # 2. PAM Validity
        is_pam_valid = len(pam) == 3 and pam.endswith("GG")
        pam_status = f"{pam} ({'Valid' if is_pam_valid else 'Invalid'})"

        # 3. Length Validity
        is_len_valid = 18 <= len(target) <= 22
        len_status = f"{len(target)} nt ({'OK' if is_len_valid else 'Not OK'})"
        
        # 4. Suitability
        suitability = "Unsuitable"
        notes = []
        if location != "Exon 2 (Correct)":
            notes.append(f"Located in wrong region or not found.")
        if not is_pam_valid:
            notes.append("Invalid spCas9 PAM.")
        if not is_len_valid:
            notes.append("Target length is out of the typical range.")
        
        if location == "Exon 2 (Correct)" and is_pam_valid and is_len_valid:
            g_count = target.count('G')
            c_count = target.count('C')
            gc_content = (g_count + c_count) / len(target) * 100
            suitability = "SUITABLE"
            notes.append(f"GC Content: {g_count+c_count}/{len(target)} = {gc_content:.1f}% (Good).")
            # Check for high repetitiveness
            if 'AAAAA' in target or 'TTTTT' in target or 'GGGGG' in target or 'CCCCC' in target or 'CTCTCT' in target or 'TC TC TC' in target:
                 notes.append("Contains simple repeats.")
            if best_candidate is None: # Mark the first suitable one as the best
                best_candidate = key
        
        # --- Print Results ---
        print(f"  - Location: {location}")
        print(f"  - PAM: {pam_status}")
        print(f"  - Target Length: {len_status}")
        print(f"  - Suitability: {suitability}")
        if notes:
            print(f"  - Notes: {' '.join(notes)}")
        print("-" * 20)

    print("\n--- Conclusion ---")
    if best_candidate:
        print(f"Both options E and K are found in Exon 2 and have valid PAMs.")
        print("However, a good sgRNA should also have a complex, non-repetitive sequence to reduce the chance of off-target binding elsewhere in the genome.")
        print(f"Option E, '{options[best_candidate]}', has a complex sequence and ideal GC content.")
        print("It is an excellent choice for targeting the second exon.")
        print("\nFinal Answer:")
        print(f"<<<{best_candidate}>>>")
    else:
        print("No suitable sgRNA candidate was found among the options.")

if __name__ == '__main__':
    analyze_sgrna_options()