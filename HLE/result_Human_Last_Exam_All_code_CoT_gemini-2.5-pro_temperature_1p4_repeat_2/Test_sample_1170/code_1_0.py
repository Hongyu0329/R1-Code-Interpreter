def solve_tt_ideals():
    """
    Solves the problem by modeling the Balmer spectrum and object supports.
    """
    # In our model, the spectrum has two irreducible components, 'p1' (generic) and 'p2' (cohomological).
    # An object generates a prime ideal if its support is irreducible.
    # In a space {p1, p2}, the irreducible closed sets are {}, {p1}, {p2}. {p1, p2} is not.
    p1 = frozenset(['p1'])
    p2 = frozenset(['p2'])
    whole_space = p1.union(p2)
    empty_set = frozenset()

    # Determine the support for the basic object types
    supports = {}
    supports['k(0)'] = whole_space
    supports['kCp(0)'] = p1
    supports['rad'] = whole_space  # [p-1](0) is rad(kCp)
    supports['gap'] = whole_space
    supports['cone'] = p2
    supports['S'] = p2

    # Compute supports for all 20 objects
    obj_supports = [None] * 20
    obj_supports[0] = supports['k(0)']  # 1. k(0)
    obj_supports[1] = supports['kCp(0)'] # 2. kCp(0)
    obj_supports[2] = supports['rad']     # 3. [p-1](0)
    obj_supports[3] = supports['rad']     # 4. rad(kCp)
    obj_supports[4] = supports['gap']     # 5. gap^1(rad(kCp))
    obj_supports[5] = supports['gap']     # 6. gap^{p-1}(rad(kCp))
    obj_supports[6] = supports['cone']    # 7. cone(tau)
    obj_supports[7] = obj_supports[6]     # 8. cone(tau)^2
    obj_supports[8] = obj_supports[6]     # 9. cone(tau)^{p-1}
    obj_supports[9] = obj_supports[6]     # 10. cone(tau)^p
    obj_supports[10] = obj_supports[1].intersection(obj_supports[6]) # 11. kCp(0) @ cone
    obj_supports[11] = obj_supports[3].intersection(obj_supports[6]) # 12. rad @ cone
    obj_supports[12] = obj_supports[4].intersection(obj_supports[6]) # 13. gap^1 @ cone
    obj_supports[13] = obj_supports[5].intersection(obj_supports[6]) # 14. gap^{p-1} @ cone
    obj_supports[14] = supports['S']      # 15. S
    obj_supports[15] = obj_supports[14].intersection(obj_supports[1]) # 16. S @ kCp
    obj_supports[16] = obj_supports[14].intersection(obj_supports[3]) # 17. S @ rad
    obj_supports[17] = obj_supports[14].intersection(obj_supports[6]) # 18. S @ cone
    obj_supports[18] = obj_supports[14].intersection(obj_supports[4]) # 19. S @ gap^1
    obj_supports[19] = obj_supports[14].intersection(obj_supports[5]) # 20. S @ gap^{p-1}

    # An object generates a prime tt-ideal if its support is irreducible
    # (i.e., empty or a single point in our 2-point model).
    prime_generators = []
    for i, supp in enumerate(obj_supports):
        if len(supp) <= 1:
            prime_generators.append(i + 1)
    
    # Identify which prime ideals are generated by this list
    generated_primes = set()
    for i in prime_generators:
        support = obj_supports[i-1]
        if support == p1:
            generated_primes.add('P_p2') # generated by object with support {p1}
        elif support == p2:
            generated_primes.add('P_p1') # generated by object with support {p2}
        elif support == empty_set:
            generated_primes.add('P_zero') # generated by object with empty support
            
    # In the 2-point model, there are 3 prime ideals, corresponding to supports {p1}, {p2} and empty set
    total_primes = {'P_p1', 'P_p2', 'P_zero'}
    num_not_generated = len(total_primes - generated_primes)

    # Format the output string
    result_str = ",".join(map(str, prime_generators)) + ";" + str(num_not_generated)
    print(result_str)

solve_tt_ideals()