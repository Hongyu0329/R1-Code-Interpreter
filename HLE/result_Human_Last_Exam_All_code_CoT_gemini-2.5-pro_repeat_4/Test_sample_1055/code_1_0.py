import numpy as np

def solve():
    """
    Computes the index [SL_2(Z) : H] where H is generated by a and b.
    The method involves showing that H is conjugate to the principal congruence
    subgroup Gamma(2).
    """
    # Step 1: Define the matrices a and b
    a = np.array([[-21, 242], [-2, 23]], dtype=np.int64)
    b = np.array([[-19, 200], [-2, 21]], dtype=np.int64)
    print("Let G = SL_2(Z) and H be the subgroup generated by a and b.")
    print(f"a =\n{a}")
    print(f"b =\n{b}")
    print("-" * 30)

    # Step 2: Verify they are in SL_2(Z) and check if they are parabolic
    det_a = round(np.linalg.det(a))
    det_b = round(np.linalg.det(b))
    tr_a = np.trace(a)
    tr_b = np.trace(b)

    print(f"det(a) = {det_a}, tr(a) = {tr_a}")
    print(f"det(b) = {det_b}, tr(b) = {tr_b}")

    if not (det_a == 1 and det_b == 1):
        print("Error: Matrices are not in SL_2(Z).")
        return
    if not (tr_a == 2 and tr_b == 2):
        print("Error: This method requires the generators to be parabolic (trace=2).")
        return
    print("The generators a and b are parabolic elements of G.")
    print("-" * 30)
    
    # Step 3: Find the fixed points (cusps)
    # For a matrix m = [[p, q], [r, s]], the fixed point z satisfies r*z^2 + (s-p)*z - q = 0.
    # For a: -2*z^2 + 44*z - 242 = 0  => (z-11)^2 = 0. Fixed point is 11.
    # For b: -2*z^2 + 40*z - 200 = 0  => (z-10)^2 = 0. Fixed point is 10.
    print("Matrix a fixes the cusp z = 11.")
    print("Matrix b fixes the cusp z = 10.")
    print("-" * 30)

    # Step 4: Find conjugating matrices M and N to simplify a and b
    # For a fixed point p/q, find M = [[p, u], [q, v]] with det=1.
    # For z=11/1, we find M = [[11, 10], [1, 1]].
    M = np.array([[11, 10], [1, 1]], dtype=np.int64)
    M_inv = np.array([[1, -10], [-1, 11]], dtype=np.int64)
    
    # For z=10/1, we find N = [[10, 9], [1, 1]].
    N = np.array([[10, 9], [1, 1]], dtype=np.int64)
    N_inv = np.array([[1, -9], [-1, 10]], dtype=np.int64)

    print(f"Conjugating matrix for a is M =\n{M}")
    print(f"Conjugating matrix for b is N =\n{N}")

    a_conj = M_inv @ a @ M
    b_conj = N_inv @ b @ N

    print(f"\nConjugating a by M gives M_inv * a * M =\n{a_conj}")
    print(f"Conjugating b by N gives N_inv * b * N =\n{b_conj}")
    
    S2 = np.array([[1, 2], [0, 1]], dtype=np.int64)
    if not (np.array_equal(a_conj, S2) and np.array_equal(b_conj, S2)):
        print("Error in conjugation calculation.")
        return
    print("\nSo, a = M * S2 * M_inv and b = N * S2 * N_inv, where S2 = [[1, 2], [0, 1]].")
    print("-" * 30)

    # Step 5: Identify the conjugated subgroup H' = M_inv * H * M
    # H = <a, b> = <M*S2*M_inv, N*S2*N_inv>
    # H' = M_inv*H*M = <S2, (M_inv*N)*S2*(M_inv*N)_inv>
    C = M_inv @ N
    C_inv = np.linalg.inv(C).astype(np.int64)
    gen2_H_prime = C @ S2 @ C_inv

    print(f"The subgroup H is conjugate to H' = <S2, C*S2*C_inv> where C = M_inv*N.")
    print(f"C = M_inv * N =\n{C}")
    print(f"The second generator of H' is C*S2*C_inv =\n{gen2_H_prime}")

    T2 = np.array([[1, 0], [2, 1]], dtype=np.int64)
    T2_inv = np.linalg.inv(T2).astype(np.int64)
    
    if np.array_equal(gen2_H_prime, T2_inv):
         print("\nThis matrix is the inverse of T2 = [[1, 0], [2, 1]].")
    else:
        print("Error: The second generator of H' is not T2_inv.")
        return
    print("-" * 30)

    # Step 6: Compute the index
    print("H' is generated by S2 and T2_inv. These are the standard generators of Gamma(2).")
    print("Therefore, H is conjugate to the principal congruence subgroup Gamma(2).")
    print("The index of a subgroup is invariant under conjugation.")
    print("So, the final equation is: [G : H] = [G : Gamma(2)].")
    print("The index [G : Gamma(2)] is the order of the quotient group G/Gamma(2), which is isomorphic to SL_2(F_2).")
    
    index = 6
    print(f"The order of SL_2(F_2) is 6.")
    print(f"Thus, the index [G : H] = {index}.")

# Run the solution
solve()