171[void main() {
    // This program calculates 100! using the smallest memory footprint for variables.
    // Total memory (z) = 171D.
    // z = sizeof(result:158) + sizeof(i:3) + sizeof(size:2) + sizeof(j:2) + sizeof(carry:2) + sizeof(product:4)

    short result[79];       // Using base 100, stores up to 158 digits.
    char i;                 // Loop counter from 2 to 100.
    short size;             // Tracks the number of 'digits' (base 100) in use.
    short j;                // Inner loop counter.
    short carry;            // Carry-over for multiplication.
    unsigned int product;   // Stores intermediate product, fits in unsigned int.

    // Initialize result array.
    for (j = 0; j < 79; j++) {
        result[j] = 0;
    }

    // Initialize for 1!
    result[0] = 1;
    size = 1;

    // Calculate factorial by multiplying with i from 2 to 100.
    for (i = 2; i <= 100; i++) {
        carry = 0;
        for (j = 0; j < size; j++) {
            product = result[j] * i + carry;
            result[j] = product % 100;
            carry = product / 100;
        }

        // Propagate the remaining carry to extend the result array.
        while (carry > 0) {
            result[size] = carry % 100;
            size++;
            carry = carry / 100;
        }
    }

    // Print the final result. The problem requires outputting each number in the final equation.
    // We print the most significant block first. Since %i takes an int, we cast the short.
    printf("%i", (int)result[size - 1]);

    // Print remaining blocks. Since there is no %02d format, we must print
    // each two-digit block as two separate single digits.
    for (j = size - 2; j >= 0; j--) {
        digit d1;
        digit d2;
        d1 = result[j] / 10;
        d2 = result[j] % 10;
        printf("%d%d", d1, d2);
    }
}]