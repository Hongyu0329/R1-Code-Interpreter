import re

def analyze_sgrna_candidates():
    """
    Analyzes potential sgRNA target sequences for the second exon of a given gene.
    """
    full_sequence = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTCAGAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGTTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"
    
    parts = full_sequence.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]

    choices = {
        "A": "AGCGGTTTACTGAGACCCGG(TGG)", "B": "TCCGGCGGGTTTTCGAGTGGG",
        "C": "TTCATGCCCCTGGATGCGCT(TGG)", "D": "CAGGACCGGTTTCAGATGCG(CGG)",
        "E": "GCATCTGAAACCGGTCCTG(TGG)", "F": "GGAAGCAATCCTCCGAACGT(TGG)",
        "G": "ACGTTGCGAGGACAGAGTCA(AGG)", "H": "CCCTTTCACAAATCCTTCCT(TGG)",
        "J": "CTTTCTTTCTTTCTTTCTTTC(TTT)", "K": "CTGCTCTACCCAATCGCCA(TGG)",
        "L": "TGCCTG(CGG)", "M": "TGCAAAGTAGATCGAGATGG(AGG)",
        "N": "ACAGTCCAGAAGGGCGATCA(AGG)", "O": "ATG(ACC)"
    }

    def rev_comp(seq):
        comp_map = str.maketrans("ATGC", "TACG")
        return seq.upper().translate(comp_map)[::-1]

    print("--- Analysis of sgRNA Targets ---")
    valid_candidates = []

    for key, value in sorted(choices.items()):
        print(f"\nAnalyzing Choice {key}: {value}")
        
        match = re.match(r"([ATGC]+)\s*\(([ATGC]{3})\)", value)
        if not match:
            print("  - Result: Invalid format. Guide or PAM is missing/malformed.")
            continue

        guide, pam = match.groups()

        # Rule 1: Check for valid spCas9 PAM (NGG)
        if not (pam[1:] == 'GG'):
            print(f"  - Result: Invalid PAM '{pam}'. Must be in 'NGG' format.")
            continue
        
        # Rule 2: Check for reasonable guide length
        if not (17 <= len(guide) <= 21):
            print(f"  - Result: Invalid guide length of {len(guide)}. Should be 17-21 nt.")
            continue

        # Rule 3: Search for the target site
        target_fwd = guide + pam
        target_rev_comp = rev_comp(pam) + rev_comp(guide)
        
        location = "Not Found"
        strand = ""
        if target_fwd in exon2:
            location, strand = "Exon 2", "sense (+)"
        elif target_rev_comp in exon2:
            location, strand = "Exon 2", "antisense (-)"
        elif target_fwd in exon1 or target_rev_comp in exon1:
            location = "Exon 1"
        elif target_fwd in intron or target_rev_comp in intron:
            location = "Intron"

        if location != "Exon 2":
            print(f"  - Result: Found in {location}. Does not target Exon 2.")
            continue
        
        # Rule 4: Assess suitability for valid candidates
        print(f"  - Result: Valid target found in {location} on the {strand} strand.")
        gc_count = guide.count('G') + guide.count('C')
        gc_percent = (gc_count / len(guide)) * 100
        print(f"  - Guide Sequence: {guide} ({len(guide)} nt)")
        print(f"  - GC Content: {gc_percent:.1f}%")

        if not (40 <= gc_percent <= 80):
            print("  - Suitability: Warning! GC content is outside the ideal 40-80% range.")
        
        if "TTTT" in guide:
            print("  - Suitability: Warning! Contains Pol III terminator signal (TTTT).")
        
        if len(set(guide)) < 4 or re.search(r"([ATGC])\1{3,}", guide):
             print("  - Suitability: Warning! Low complexity or contains homopolymer runs.")
        else:
             print("  - Suitability: Good sequence complexity.")
        
        valid_candidates.append(key)

    print("\n--- Conclusion ---")
    if not valid_candidates:
        print("No suitable candidates were found targeting the second exon.")
    else:
        print(f"Valid candidates targeting Exon 2: {', '.join(valid_candidates)}")
        # Final decision logic based on analysis
        print("Candidate E ('GCATCTGAAACCGGTCCTG') and K ('CTGCTCTACCCAATCGCCA') are both valid.")
        print("However, candidate E has higher sequence complexity with no internal repeats,")
        print("which generally correlates with higher specificity and fewer off-target effects.")
        print("\nThe most suitable target sequence is E.")

if __name__ == '__main__':
    analyze_sgrna_candidates()