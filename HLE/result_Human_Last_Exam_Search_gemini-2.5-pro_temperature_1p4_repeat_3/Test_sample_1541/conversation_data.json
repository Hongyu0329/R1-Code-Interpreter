{
  "question": "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>.",
  "response_list": [
    "To solve this problem in the most memory-efficient way, we should avoid storing the entire input string in memory. The core idea is to read the input character by character, count the occurrences of each number (1, 2, 3, and 4), and then print the result based on these counts. This approach, known as counting sort, is highly effective because the range of numbers is very small.\n\nThe most memory-efficient C program for this task is as follows:\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\n/**\n * This program solves the \"Xenia and Sum\" problem with maximum memory efficiency.\n *\n * It operates by reading the input sum one character at a time, which avoids\n * allocating a large buffer for the entire string. It uses an array of four counters\n * for the numbers 1, 2, 3, and 4. Since the maximum length of the input string is 1000,\n * the maximum count for any single number is 501 (e.g., \"1+1+...+1\"). A 'short'\n * data type is sufficient to hold these counts. After counting, the program\n * constructs and prints the sorted sum directly.\n */\nint main() {\n    // Array to store counts for numbers 1, 2, 3, and 4.\n    // 'short' (2 bytes) is used instead of 'int' to save memory.\n    short counts[4] = {0};\n\n    // Variable to hold character from getchar(). Must be 'int' to handle EOF.\n    int ch;\n\n    // Flag for printing the '+' separator. 'bool' (1 byte) is most efficient.\n    bool is_first_term = true;\n\n    // Read the input character by character to count the numbers.\n    while ((ch = getchar()) != '\\n' && ch != EOF) {\n        if (ch == '1') {\n            counts[0]++;\n        } else if (ch == '2') {\n            counts[1]++;\n        } else if (ch == '3') {\n            counts[2]++;\n        } else if (ch == '4') {\n            counts[3]++;\n        }\n        // The '+' characters are ignored.\n    }\n\n    // Print the sorted sum.\n    // Outer loop counter 'i' only goes up to 3, so 'char' (1 byte) is sufficient.\n    for (char i = 0; i < 4; i++) {\n        // Inner loop counter 'j' can go up to 501, so 'short' (2 bytes) is used.\n        for (short j = 0; j < counts[i]; j++) {\n            if (!is_first_term) {\n                putchar('+');\n            }\n            putchar(i + '1'); // Convert index (0-3) back to character ('1'-'4')\n            is_first_term = false;\n        }\n    }\n    putchar('\\n');\n\n    return 0;\n}\n\n```\n\n### Memory Usage Calculation (m)\n\nTo calculate the total memory `m` used by the variables in this program, we sum the sizes of each variable declared in the `main` function. The calculation is based on typical data type sizes in modern C compilers (like GCC on a 64-bit system), where `sizeof(short)` is 2 bytes, `sizeof(int)` is 4 bytes, `sizeof(bool)` is 1 byte, and `sizeof(char)` is 1 byte.\n\n*   `short counts[4]`: This array stores the four counters. The memory used is 4 * `sizeof(short)` = 4 * 2 = 8 bytes.\n*   `int ch`: This variable holds the character from input. `getchar()` returns an `int`, so it requires `sizeof(int)` = 4 bytes.\n*   `bool is_first_term`: This boolean flag controls the printing of the `+` symbol. It requires `sizeof(bool)` = 1 byte.\n*   `char i`: The outer loop counter only needs to go from 0 to 3. A `char` is sufficient, using `sizeof(char)` = 1 byte.\n*   `short j`: The inner loop counter can go up to 501. A `short` is sufficient, using `sizeof(short)` = 2 bytes.\n\nThe total memory usage `m` is the sum of the memory used by these variables:\n\n`m` = (memory for `counts`) + (memory for `ch`) + (memory for `is_first_term`) + (memory for `i`) + (memory for `j`)\n`m` = 8 + 4 + 1 + 1 + 2 = 16 bytes.\n\n<<<16>>>"
  ],
  "user_prompt_list": [
    "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>."
  ],
  "system_message": ""
}