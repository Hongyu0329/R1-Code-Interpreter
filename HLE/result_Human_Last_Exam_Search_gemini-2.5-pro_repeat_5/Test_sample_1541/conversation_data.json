{
  "question": "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>.",
  "response_list": [
    "Here is the most memory-efficient C program to solve the problem.\n\n### C Program\n\nThis program reads the sum character by character, which is highly memory-efficient as it avoids storing the entire input string (up to 1000 characters). It uses a counting sort approach, which is ideal since there are only four possible numbers (1, 2, 3, 4).\n\n```c\n#include <stdio.h>\n\n/**\n * This program rearranges the terms in a sum consisting of numbers 1, 2, 3, and 4\n * so that they are in non-decreasing order.\n *\n * This implementation is optimized for minimal memory usage by processing the input\n * as a stream instead of storing the entire string.\n */\nint main() {\n    // --- Variable Declaration and Memory Analysis ---\n\n    // counts: An array to store the frequency of the numbers 1, 2, 3, and 4.\n    // The maximum number of any single digit is 501 (for a string like \"1+1+...+1\").\n    // An 'unsigned short' (2 bytes) can hold values up to 65535, which is sufficient.\n    // Memory for counts = 4 * sizeof(unsigned short) = 4 * 2 = 8 bytes.\n    unsigned short counts[4] = {0, 0, 0, 0};\n\n    // c: A variable to hold the character read from the input stream.\n    // getchar() returns an 'int' to properly handle the End-Of-File (EOF) value.\n    // Memory for c = sizeof(int) = 4 bytes.\n    int c;\n\n    // i: A loop counter for iterating through the counts array (from 0 to 3).\n    // A 'char' (1 byte) is sufficient for this small range.\n    // Memory for i = sizeof(char) = 1 byte.\n    char i;\n\n    // is_first_term: A flag to ensure the '+' symbol is not printed before the first number.\n    // A 'char' (1 byte) is used as a boolean flag.\n    // Memory for is_first_term = sizeof(char) = 1 byte.\n    char is_first_term = 1;\n\n    // --- Logic ---\n\n    // 1. Read input character by character, updating the count for each number found.\n    while ((c = getchar()) != EOF && c != '\\n') {\n        if (c >= '1' && c <= '4') {\n            // The character '1' corresponds to index 0, '2' to 1, and so on.\n            counts[c - '1']++;\n        }\n    }\n\n    // 2. Print the numbers in sorted order based on the stored counts.\n    for (i = 0; i < 4; ++i) {\n        while (counts[i] > 0) {\n            if (!is_first_term) {\n                putchar('+');\n            }\n            putchar(i + '1');\n            is_first_term = 0;\n            counts[i]--;\n        }\n    }\n    putchar('\\n');\n\n    return 0;\n}\n```\n\n### Memory Usage Calculation (m)\n\nThe total memory `m` used for variables in this program is the sum of the memory allocated for each variable declared in the `main` function. The sizes are based on typical C compilers (like GCC on a 64-bit system).\n\n*   `unsigned short counts[4]`: 4 elements * 2 bytes/element = 8 bytes\n*   `int c`: 4 bytes\n*   `char i`: 1 byte\n*   `char is_first_term`: 1 byte\n\nTotal memory `m` = 8 + 4 + 1 + 1 = 14 bytes.\n\n<<<14>>>"
  ],
  "user_prompt_list": [
    "This is a problem in a competitive programming contest.\n\nXenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.\n\nThe teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2, 3 and 4. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+4.\n\nYou've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.\n\nInput\nThe first line contains a non-empty string s — the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2, 3, and 4. String s is at most 1000 characters long.\n\nOutput\nPrint the new sum that Xenia can count.\n\nTask:\n\nWrite the most memory-efficient C program to solve this problem. Answer m as the total memory in bytes used for variables of this problem. \nOnce you feel you are ready for the final answer, directly return the answer with the format <<<answer content>>> at the end of your response, e.g. <<<C>>>, <<<9.8>>>."
  ],
  "system_message": ""
}