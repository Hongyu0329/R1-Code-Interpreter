import sys

def reverse_complement(dna_sequence):
    """Returns the reverse complement of a DNA sequence."""
    complement_map = str.maketrans("ATGC", "TACG")
    return dna_sequence.upper().translate(complement_map)[::-1]

def analyze_targets():
    """
    Analyzes potential sgRNA targets for a given gene sequence.
    """
    full_seq = "ATGTGTGCCTGCGGGATACTTTTGACTTTTACTTTGCTTTTGCATTTTCTTGGTGTTCACTCAATGAATCCTCTGTTTCCAAGCGCATCCAGGGGCATGAAAGTGTCTAAGTCTGTTCCTGCTGAGGGCAACAGGAGAGCAAAATACGGCAAGAATGTGCTGTCAGCATCACTGTTATCCGGAGACATACAGTCCAGAAGGGCGATCAAGGATGCGATTGAACCTCACGATTACATGATTTCCATATACAAGACCTTTTCAGCGGCTGAAAAACTGGGACTGAACGCGAGTTTTTTCCGCTCGTCTAAAGCAGCAAACACCATCACGAGCTTTGTGGACGAGGGTCAAG^GTTAGTTATTTCTACTTATACAAGCAACAGTGATTTCAAACGCACACGTACTGATTCTATATTGGTACTCACAGGGAAAAAAAAAAAAAAAACATTTGTATACAATTCAAACAACTCTTAAAGGAATACAGTCAAATGTGTCAGTGAACAGATGGAAACAAAGCATTTTGAATATTAGGCCTATATCATCTATGATACTGCGGAAAATCTTCAAGAAATCTTTTTCCCCTAATAGTAAAAATAATGACAACAATATATGTATAACATTATACACTTCTGTTTACAATCTTGCATAAAATAAGTTGTGTTTGCATCAAAGTGTGTATACATGCACTGTCCATTTCAAATATTTTTTATTGGAATGTGTAGGAATTTTCACGATGTAGGCAGGTTATTATCACTATAAAGTGCCTTAGATGTCCCACAAGATTGAATCAGTCCCATATGAGCATAATGCGAAATTGATGTTTTAATATGATTGGTTAAACTTGTACACACATGCAGGTAGAATTATGAGTGTTTTGAAACATGTTTTTGCCAATTATTGCCATAGTCTTTTATTGAATGGATGTGATTTTGCCATGTCCCACACACTGCACAGCCAAGTTCAGTAAGTCTAAAAAGTAGCTAAATTAGATAAATTTTTTTTAAATGTTTAAGTATTCTTTCTATTCTTACAGTTATTTTGAAAACTAAATCATTTTTATAACTTTTATTTTTTTATTCTTTTATAATATTATTAATCATTTTGCACGAGTCTTTGAGTTTGCTGTCCACCCTGTCATGATGTAGTAAATCCCCTTTAAGAAACCCTCTGATGTACTCATTGGCATCCCCATGCCTATTTTGCTTTTCTTCAGAGGAGGTTAAAAAAACTGATGTGCACACATTAAATATCTACATATATGTTTCCTATTTTTCATCATATTGTGTTTGAAACCGAATGTGGTCAAGCTTAACATGTCCACCCTGTCATAGTAAAATATTAATTAATATAAAAAATTCGGAAATCAAAGATAGCTTTTAAACTGTATACAAAGAGCTTAAATAAGGAAACACTTTACCAGCTGCAGGTTCAACCTGTGTTAAATAAATGCTATCTTTAGCCAAAAATGTCCTCCTTGTTATTGTCCACCCTTTCACAAATCCTTCCTTGGGTGGACATATGCATCGTTATTGACACTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTCTTTTTTGTTAATCAGCTAATGTTTTATTATGGTACATCACATACATACTACACCAGTAGATGCAATACATAAGTGGACAATACAAATCTTTTGGCAATATTTATCTCAGTCTATATAAAGAATATCCTTTTAAAGTCCATATAAGGCAGCTCATTGACTGTTTGAAATTAAAATACATTATTTATCCTATTCTGGAAAAGAAAAAATATGATACATTTGTGCGTTGATGGATTTGAAACCACACTGGACTGAACTAATTTGAACTTTTAATTTCAATTCACTACAACTTCTATGTTAAGCTGCTTAGACACAATTTACATTACAGGTGTCAAATCCAGTTTCTTAAGAGCCACAGCTCTGCACAGTTTAGGGTTAACCCTAATTAAACACACCTGATCAAACTAATTGAGTCCTTCAGGCTTGTTTGATACCTACAGGTAGGTTTGTTAAAGCAAGGTTGGAACTAAATTGTGCAGAGCTGCGGCCCTTCAGGAACTAGATTTGACACCTAATTTACATTATGGAAACGCTATAGAAATAAAGATAAATTGAATTGAATAGATTTTTCTCCTCCAAAACACTATATATAAAAATACTAATTAGCAAATGCTAGTATTAGAAAAAAAAATTAGAACCTAGCTTTAAAAACTTTAGCATAATGAAAGAAACAGAGACACAAGACAGAAATAAATTTCAACATATGTCACCTTAATTAGTTAAAAACGAGTTCTCGATCTGCACATGCCATAACAGATATTGTAAATTTTGTGGATGCAGATCTAGTGTCAACAAGCATCTGTTCTCTTTGTTTCAG^ATGACCATTTGAACTCTCCACTTTGGAGACAGAAATATTTATTCGACGTATCAACGCTTTCTGAAAATGTGGAGATCCTGGGTGCCGAACTGAGGATTTACACAAAGATCTCCGGAAGCTTCCGCGCATCTGAAACCGGTCCTGTGGAAATACAGCTTCTCTCCTGCCAGTCGCACACTGTCCTTGATTCACAAACTTTGGATCTGGAGGATGCACATAAACCAAAATGGGAAGTTTTCGACGTCTGGGAGATTTTTAAGGAACGTCAGCACCACTCTCATGGCACCCGCTTCTGTTTAGAGCTCAGGGCCACACTGGATAATCCAGAGAGAGAAATTGATTTGCAATATCTTGGATTTCACAGACATGGCCGCCCGCAACTGAAGAAAGCCATACTGGTTGTTTTCACAAGGTCAAAAAAGAGGCAAAGTCTTTTTTATGAAAAAAGAGAGAAGATCAAGCTATGGGGTCTGGATAGTATTGGTAAGGAAAGAAGATCCCACTCGAAAACCCGCCGGAGCAGACGGACTGCTCTACCCAATCGCCATGGCAAGAGACATGGTAAAAAGTCAAAATCTAGATGCAGCAAAAAGCCACTGCATGTCAATTTCAGAGAGCTGGGTTGGGACGATTGGGTCATCGCTCCATTAGATTATGAGGCTTATCACTGTGAGGGCATGTGTGACTTTCCCCTCCGATCTCACCTGGAACCAACCAATCATGCCATCATACAAACTCTAATGAACTCAATGAACCCCAGCAACATGCCACCCAGCTGTTGCGTCCCCTCCAAACTCAGTCCCATTAGCATCTTGTACATTGACGCAGGAAATAATGTTGTGTACAAGCAGTATGAAGACATGGTAGTGGAGTCCTGCGGCTGCAGATGA"

    parts = full_seq.split('^')
    exon1 = parts[0]
    intron = parts[1]
    exon2 = parts[2]

    choices = {
        'A': ('AGCGGTTTACTGAGACCCGG', 'TGG'), 'B': ('TCCGGCGGGTTTTCGAGTG', 'GGG'),
        'C': ('TTCATGCCCCTGGATGCGCT', 'TGG'), 'D': ('CAGGACCGGTTTCAGATGCG', 'CGG'),
        'E': ('GCATCTGAAACCGGTCCTG', 'TGG'), 'F': ('GGAAGCAATCCTCCGAACGT', 'TGG'),
        'G': ('ACGTTGCGAGGACAGAGTCA', 'AGG'), 'H': ('CCCTTTCACAAATCCTTCCT', 'TGG'),
        'I': ('TTCACCCGCACCTTGAACGG', 'AGG'), 'J': ('CTTTCTTTCTTTCTTTCTTTC', 'TTT'),
        'K': ('CTGCTCTACCCAATCGCCA', 'TGG'), 'L': ('TGCCTG', 'CGG'),
        'M': ('TGCAAAGTAGATCGAGATGG', 'AGG'), 'N': ('ACAGTCCAGAAGGGCGATCA', 'AGG'),
        'O': ('ATG', 'ACC')
    }

    print("--- Analysis of sgRNA Target Sequences ---")
    valid_candidates = {}
    for key, (guide, pam) in choices.items():
        pam_valid = (len(pam) == 3 and pam[1] == 'G' and pam[2] == 'G')
        if not pam_valid:
            print(f"Choice {key}: Invalid spCas9 PAM ({pam}). Discarded.")
            continue

        target_seq = guide + pam
        target_seq_rc = reverse_complement(target_seq)
        
        status = "Not Found"
        if exon2.find(target_seq) != -1:
            status = f"VALID. Found in exon 2 at index {exon2.find(target_seq)}."
            valid_candidates[key] = choices[key]
        elif exon2.find(target_seq_rc) != -1:
            status = f"VALID. Found in exon 2 (on reverse strand) at index {exon2.find(target_seq_rc)}."
            valid_candidates[key] = choices[key]
        elif exon1.find(target_seq) != -1 or exon1.find(target_seq_rc) != -1:
            status = "INVALID. Target is in exon 1."
        elif intron.find(target_seq) != -1 or intron.find(target_seq_rc) != -1:
            status = "INVALID. Target is in the intron."

        print(f"Choice {key}: {status}")

    print("\n--- Final Evaluation of Valid Candidates ---")
    if not valid_candidates:
        print("No valid candidates were found in exon 2.")
        return

    best_choice = None
    max_score = -1

    for key, (guide, pam) in valid_candidates.items():
        gc_content = (guide.count('G') + guide.count('C')) / len(guide) * 100
        length = len(guide)
        
        print(f"\nEvaluating Candidate: {key}")
        print(f"  Guide Sequence: {guide}")
        print(f"  Length: {length} nt, GC Content: {gc_content:.1f}%")

        score = 0
        if length < 17:
            print("  Comment: Too short. High risk of off-targets. Poor choice.")
            score = -1
        elif 'AAAAA' in guide or 'TTTTT' in guide or 'GGGG' in guide or 'CCCCC' in guide:
            print("  Comment: Contains polynucleotide tracts. May reduce efficiency.")
            score = length * 0.5
        elif 'CTTTCTTT' in guide or 'AGAGAG' in guide: # Simple complexity check
            print("  Comment: Contains low-complexity repeats. Increased risk of off-targets.")
            score = length * 0.5
        else:
            print("  Comment: Good length and complexity. Strong candidate.")
            score = length
        
        if score > max_score:
            max_score = score
            best_choice = key
    
    print("\n--- Conclusion ---")
    print(f"The most suitable sgRNA target is choice {best_choice}.")
    print(f"Reasoning: Candidate {best_choice} provides the best balance of target specificity (correct location), guide length ({len(valid_candidates[best_choice][0])} nt), and high sequence complexity, which suggests the lowest potential for off-target binding.")

analyze_targets()
<<<E>>>