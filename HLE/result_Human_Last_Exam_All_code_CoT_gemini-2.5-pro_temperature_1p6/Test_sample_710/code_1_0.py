import sys

def solve():
    """
    Determines the smallest number N such that any integer >= N can be written
    as a sum of distinct numbers of the form 2n^2 + 3n + 1.
    """
    # Set a limit for the numbers to check. If the script fails to find N,
    # this limit may need to be increased.
    LIMIT = 500

    # 1. Generate the set of numbers (terms)
    terms = []
    n = 1
    while True:
        term = 2 * n * n + 3 * n + 1
        if term >= LIMIT:
            break
        terms.append(term)
        n += 1

    if not terms:
        print("No terms generated. The LIMIT might be too small.")
        return

    # 2. Use dynamic programming to find all reachable sums
    reachable = [False] * LIMIT
    reachable[0] = True  # Sum 0 is reachable with an empty set of terms

    for term in terms:
        for i in range(LIMIT - 1, term - 1, -1):
            reachable[i] = reachable[i] or reachable[i - term]

    # 3. Find the smallest N that starts a consecutive block of reachable numbers.
    # The length of this block is determined by the smallest term in the set.
    consecutive_length = terms[0]

    for N in range(1, LIMIT - consecutive_length):
        # Check if N, N+1, ..., N + consecutive_length - 1 are all reachable
        is_consecutive_block = all(reachable[N + i] for i in range(consecutive_length))
        
        if is_consecutive_block:
            # We found our N. Now, provide the explanation and the final equation.
            print("The set of numbers is generated by the formula f(n) = 2*n^2 + 3*n + 1.")
            print(f"The first few numbers in the set are: {terms[:6]}...")
            print(f"\nWe are looking for the smallest number N such that any integer greater than or equal to N")
            print(f"can be written as a sum of distinct numbers from this set.")
            print(f"This is the first number that starts a consecutive sequence of {consecutive_length} representable sums.")
            
            # Find a combination of terms that sum up to N
            def find_sum_combination(target, terms_subset):
                if target == 0:
                    return []
                if not terms_subset or target < 0:
                    return None
                
                term = terms_subset[-1]
                remaining_terms = terms_subset[:-1]
                
                # Try including the current term
                res = find_sum_combination(target - term, remaining_terms)
                if res is not None:
                    res.append(term)
                    return res
                
                # Try excluding the current term
                return find_sum_combination(target, remaining_terms)

            combination = find_sum_combination(N, [t for t in terms if t <= N])
            
            print(f"\nThe smallest such number N is {N}.")
            if combination:
                print(f"An example of how {N} can be formed is shown in the equation below:")
                # The final required equation
                print(f"{N} = {' + '.join(map(str, sorted(combination)))}")
            else:
                # This case should not be reached if the logic is correct
                print(f"Could not find a representation for {N}, there may be an error in the logic.")
            
            # Print the final answer in the required format
            sys.stdout.write(f"\n<<<{N}>>>")
            return

    # If the loop finishes without returning, the limit was too small.
    print(f"A solution could not be found within the search limit of {LIMIT}.")
    print("Please try increasing the LIMIT variable in the script.")

solve()