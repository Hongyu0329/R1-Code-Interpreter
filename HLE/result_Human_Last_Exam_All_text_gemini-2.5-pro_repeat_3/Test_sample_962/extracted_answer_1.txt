The design consists of three main phases: a prerequisite Distributed Key Generation (DKG), an offline pre-computation phase, and a two-round online signing phase.

**1. Prerequisite: Distributed Key Generation (DKG)**
- A DKG protocol (like Pedersen's) is used to create a shared secret key.
- This results in a single group public key `Y`, while each of the `n` parties `P_i` holds a secret share `s_i` of the corresponding private key `x`. No single party knows `x`.

**2. Offline Pre-computation Phase**
- To ensure a fast online protocol, each party `P_i` pre-generates multiple pairs of secret nonces `(d_{ij}, e_{ij})` and publishes the corresponding public commitments `(D_{ij} = g^{d_{ij}}, E_{ij} = g^{e_{ij}})`.

**3. Two-Round Online Signing Phase**
This phase is executed by a set `S` of `t` participating signers to sign a message `m`.

**Round 1: Commitment**
1.  Each signer `P_i` in `S` selects a fresh, unused pair of public nonce commitments `(D_i, E_i)` from their pre-computed set.
2.  Each signer `P_i` broadcasts `(D_i, E_i)` to all other signers in `S`.

**Round 2: Partial Signature Generation**
1.  After receiving all commitments `(D_j, E_j)` from every other signer `P_j` in `S`, each signer `P_i` performs the following steps:
2.  **Compute Binding Factors:** For each participant `j \in S`, compute a binding factor `\rho_j = H(j, m, \{(k, D_k, E_k) | k \in S \})`. This hash binds each participant's contribution to the message and the full set of commitments, which is the key to achieving tight security.
3.  **Compute Group Nonce Commitment:** Compute the group commitment `R = \prod_{j \in S} (D_j \cdot (E_j)^{\rho_j})`.
4.  **Compute Challenge:** Compute the Schnorr challenge `e = H(R, Y, m)`.
5.  **Compute Partial Signature:** Using its secret key share `s_i`, the corresponding secret nonce pair `(d_i, e_i)`, and the Lagrange coefficient `\lambda_i` for the group `S`, signer `P_i` computes its partial signature: `sigma_i = (d_i + e_i \cdot \rho_i) + e \cdot \lambda_i \cdot s_i`.
6.  `P_i` sends the partial signature `sigma_i` to a designated aggregator.

**Signature Aggregation:**
- The aggregator collects the `t` partial signatures `\sigma_i` and sums them to produce the final signature value `s = \sum_{i \in S} \sigma_i`.
- The final output is a standard Schnorr signature `(R, s)`, which can be publicly verified.