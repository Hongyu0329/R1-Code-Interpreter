A detailed step-by-step design for a tightly secure t-out-of-n threshold signature scheme with a two-round signing protocol can be constructed based on the FROST (Flexible Round-Optimized Schnorr Threshold) protocol. The design proceeds in two main phases: Distributed Key Generation (DKG) and a two-round Signing Protocol.

**Phase 1: Distributed Key Generation (DKG)**
A robust Pedersen VSS-based DKG is used.
1.  **Setup:** Each of the `n` parties generates a secret polynomial `f_i(z)` of degree `t-1` and broadcasts commitments to its coefficients.
2.  **Sharing:** Each party sends polynomial evaluations `f_i(j)` secretly to every other party `j`.
3.  **Verification & Aggregation:** Parties verify the received shares. The final secret share for party `i` is `x_i`, the sum of all valid shares it received. The group's public key `Y` is derived from the public commitments. This phase establishes a shared public key `Y` and individual secret shares `x_i` without any single party learning the full secret key `x`.

**Phase 2: Two-Round Signing Protocol**
For a set `S` of `t` signing participants and a message `m`:
*   **Round 1 (Commitment):** Each participant `i` in `S` selects two secret nonces, `d_i` and `e_i`, and broadcasts their public commitments `D_i = d_i*P` and `E_i = e_i*P`, where `P` is the group generator. These nonces must be single-use.

*   **Round 2 (Partial Signature):**
    1.  Upon receiving all commitments `(D_j, E_j)` from `j` in `S`, each participant `i` first computes a "binding factor" `rho_j` for each participant by hashing the message `m`, participant index `j`, and the full set of nonce commitments: `rho_j = H(j, m, {D_k, E_k}_{k \in S})`. This step is crucial for achieving tight security.
    2.  Each participant `i` computes the group commitment `R = \sum_{j \in S} (D_j + rho_j * E_j)` and the challenge `c = H(R, Y, m)`.
    3.  Each participant `i` then calculates their partial signature using their secret share `x_i`, their nonces `(d_i, e_i)`, their binding factor `rho_i`, the challenge `c`, and their Lagrange coefficient `L_i`: `z_i = d_i + (e_i * \rho_i) + c * L_i * x_i`.
    4.  Each participant `i` sends their partial signature `z_i` to a designated aggregator.

**Aggregation and Verification**
1.  The aggregator collects the `t` partial signatures. For robustness, it must verify each `z_i` individually before combining them.
2.  The aggregator computes the final signature `z = \sum_{i \in S} z_i`.
3.  The complete signature for message `m` is the pair `(R, z)`. Any party can verify this signature against the group public key `Y` by checking if `z*P == R + c*Y`, after re-computing `c = H(R, Y, m)`.