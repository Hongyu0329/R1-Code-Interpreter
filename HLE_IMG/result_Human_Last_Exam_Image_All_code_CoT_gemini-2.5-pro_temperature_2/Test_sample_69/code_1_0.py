import itertools

def find_possible_ca_rules():
    """
    Calculates the possible elementary cellular automaton rules based on the first step of evolution.

    The analysis reveals that the full pattern shown in the image cannot be generated by any single
    elementary cellular automaton (ECA) rule due to contradictions in state transitions. For example,
    the neighborhood (1,1,0) yields different outputs at different times.

    Therefore, this script operates on the hypothesis that the question asks for all ECA rules
    consistent with only the first step of the evolution (from row 0 to row 1).

    The initial state (row 0) is a single '1' surrounded by '0's: ...0001000...
    The next state (row 1) is: ...0011100...

    From this first transition, we can infer the rules for the neighborhoods that appear:
    - Neighborhood (0,0,0) -> cell below is 0.  (e.g., center at grid column 5)
    - Neighborhood (0,0,1) -> cell below is 1.  (e.g., center at grid column 7)
    - Neighborhood (0,1,0) -> cell below is 1.  (e.g., center at grid column 8)
    - Neighborhood (1,0,0) -> cell below is 1.  (e.g., center at grid column 9)

    The standard ECA rule is an 8-bit number where each bit corresponds to the output for a
    neighborhood, ordered from '111' (bit 7) down to '000' (bit 0).
    The constraints from the first step are:
    - bit 0 (for '000') = 0
    - bit 1 (for '001') = 1
    - bit 2 (for '010') = 1
    - bit 4 (for '100') = 1

    The other four neighborhoods ('111', '110', '101', '011') do not appear in the first step,
    so their corresponding bits (7, 6, 5, 3) are unconstrained. There are 2^4 = 16 such rules.
    This script generates and lists them.
    """

    # The value from the bits that are fixed by the t=0 -> t=1 transition.
    # The rule is 'b7 b6 b5 1 b3 1 1 0'.
    # Fixed part: '...1.110', which is 1*16 + 1*4 + 1*2 + 0*1 = 22.
    fixed_bits_value = 0b00010110

    # These are the bit positions for the neighborhoods that do not appear.
    # Their values can be either 0 or 1.
    variable_bit_positions = [7, 6, 5, 3]  # For neighborhoods 111, 110, 101, 011

    possible_rules = []

    # Iterate through all 2^4 = 16 combinations for the variable bits.
    for combination in itertools.product([0, 1], repeat=len(variable_bit_positions)):
        rule_number = fixed_bits_value
        # Add the values for the current combination of variable bits.
        for i, bit_value in enumerate(combination):
            if bit_value == 1:
                rule_number += (1 << variable_bit_positions[i])
        possible_rules.append(rule_number)

    # Sort the rules in increasing order as requested.
    possible_rules.sort()

    # Print the result as a comma-separated string.
    print(','.join(map(str, possible_rules)))

find_possible_ca_rules()